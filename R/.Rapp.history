ou.tr <- function(phylo, alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(ancestral.state, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		}#
      	ou.tr(phy, alpha=exp(vo$par[1]))
ou.tr <- function(phylo, alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(ancestral.state, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	ou.tr(phy, alpha=exp(vo$par[1]))
reml.out <- ou.tr(phy, alpha=exp(vo$par[1]))
if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=exp(param))#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}
}
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root
if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=exp(param))[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
UCI
LCI
exp( LCI )
exp( UCI )
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))
ouCurve <- Vectorize(ou.fun)
curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
curve(ouCurve(x, FALSE), from = exp(lowerBound[1]), to = exp(upperBound[1]), xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        if (is.ultrametric(phy)) {#
        	curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        		} else {#
        		curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        		}#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }#
      }
ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }
curve(ouCurve(x, FALSE), from = exp(lowerBound[1]), to = exp(upperBound[1]), xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
exp(lowerBound[1])
exp(upperBound[1])
curve(ouCurve(x, FALSE), from = exp(lowerBound[1]), to = exp(upperBound[1]), xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
par(oma=c(8,8,8,8))
curve(ouCurve(x, FALSE), from = exp(lowerBound[1]), to = exp(upperBound[1]), xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
reml.lik
reml.out
? 	curve
curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
ouCurve(x, FALSE)
Vectorize(ou.fun)
in.1 <- exp(lowerBound[1])
in.2 <- exp(lowerBound[2])
curve(ouCurve(x, FALSE), from = in.1, to = in.2, xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}
curve(ouCurve(x, FALSE), from = in.1, to = in.2, xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
ouCurve <- Vectorize(ou.fun)
par(oma=c(8,8,8,8))#
        			in.1 <- exp(lowerBound[1])#
        			in.2 <- exp(lowerBound[2])#
        		curve(ouCurve(x, FALSE), from = in.1, to = in.2, xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
exp(lowerBound[1])
exp(lowerBound[2])
in.2 <- exp(upperBound[2])
curve(ouCurve(x, FALSE), from = in.1, to = in.2, xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
in.2
in.2 <- exp(upperBound[1])
in.2
curve(ouCurve(x, FALSE), from = in.1, to = in.2, xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        if (is.ultrametric(phy)) {#
        	ouCurve <- Vectorize(ou.fun)#
        	curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
			}#
		} else {#
			ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		in.1 <- exp(lowerBound[1])#
        	in.2 <- exp(upperBound[1])#
        		curve(ouCurve(x, FALSE), from = in.1, to = in.2, xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(exp(LCI[1]) exp(vo$par[1]), exp(UCI[1])), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        		}
c(exp(LCI[1])
)
ouCurve <- Vectorize(ou.fun)#
        		in.1 <- exp(lowerBound[1])#
        	in.2 <- 2#
        		curve(ouCurve(x, FALSE), from = in.1, to = in.2, xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
modelCIs
if (modelCIs) a
abline(v = c(exp(LCI[1]) exp(vo$par[1]), exp(UCI[1])), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
abline(v = c(exp(LCI[1]), exp(vo$par[1]), exp(UCI[1])), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
vo$value[1]
vo$par
vo$par <- exp(vo$par)
out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }
out
if (profilePlot) {#
        par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        if (is.ultrametric(phy)) {#
        	ouCurve <- Vectorize(ou.fun)#
        	curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
			}#
		} else {#
			ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x, FALSE), from = lowerBound[1], to = lowerBound[2], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        		}#
      }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        if (is.ultrametric(phy)) {#
        	ouCurve <- Vectorize(ou.fun)#
        	curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
		} else {#
			ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x, FALSE), from = lowerBound[1], to = lowerBound[2], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        		}
ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x, FALSE), from = lowerBound[1], to = lowerBound[2], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        		}
lowerBound[1]
vo$par <- exp(vo$par)#
      	UCI <- exp(UCI)#
      	LCI <- exp(LCI)#
      	lowerBound[1] <- exp(lowerBound[1])#
        upperBound[1] <- exp(upperBound[1])
ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x, FALSE), from = lowerBound[1], to = lowerBound[2], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
        if(!is.ultrametric(phy)) lambda <- exp(lambda)#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      vcv.matrix <- NULL#
      if (!is.ultrametric(phy)) {#
      	ou.tr <- function(phylo, alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(ancestral.state, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	reml.out <- ou.tr(phy, alpha=exp(vo$par[1]))#
#
      if (modelCIs == TRUE) {#
      	if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }#
      !is.ultrametric(phy) {#
      	vo$par <- exp(vo$par)#
      	UCI <- exp(UCI)#
      	LCI <- exp(LCI)#
      	lowerBound[1] <- exp(lowerBound[1])#
        upperBound[1] <- exp(upperBound[1])#
      }
vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
        if(!is.ultrametric(phy)) lambda <- exp(lambda)#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      vcv.matrix <- NULL#
      if (!is.ultrametric(phy)) {#
      	ou.tr <- function(phylo, alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(ancestral.state, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	reml.out <- ou.tr(phy, alpha=exp(vo$par[1]))#
      		}
if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
!is.ultrametric(phy) {#
      	vo$par <- exp(vo$par)#
      	UCI <- exp(UCI)#
      	LCI <- exp(LCI)#
      	lowerBound[1] <- exp(lowerBound[1])#
        upperBound[1] <- exp(upperBound[1])#
      }
lowerBound
lowerBound[1] <- exp(lowerBound[1])#
        upperBound
upperBound[1]
model = NULL; modelCIs = TRUE; nodeIDs = NULL; rateType = NULL; minCladeSize = 1; nSplits = 2; splitTime = NULL; boundaryAge = 10; testAge = 1; restrictNode = NULL; lambdaEst = FALSE; acdcScalar = FALSE; branchLabels = NULL; hiddenSpeciation = FALSE; full.phy = NULL; useMean = FALSE; profilePlot = FALSE; lowerBound = NULL; upperBound = NULL; covPIC = TRUE; n.cores = 1; tol = NULL; meserr = NULL; returnPhy = FALSE; print.warnings = FALSE; mode.order=NULL; rate.var=FALSE#
controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5)#
sortedData <- sortTraitData(phy=anolis.tree, y=anolis.data, data.name="Male_SVL", pass.ultrametric=TRUE)#
phy <- sortedData$phy#
male.length <- sortedData$trait#
model <- tolower(model)#
  all.models <- c("bm", "kappa", "lambda", "delta", "ou", "acdc", "psi", "multipsi", "trend", "free", "clade", "tm1", "tm2", "timeslice")#
  if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
  lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
  if (acdcScalar && !is.null(nodeIDs)) upperBound <- -1e-6#
	x <- NULL#
#
acdcScalar = F#
model="modeslice"#
#
mammal.mass <- read.csv("~/Documents/motmotpaper/simulation.time.slice/mammals/mammal_mass.csv", row.names=1)#
mammal.phy <- read.tree("~/Documents/motmotpaper/simulation.time.slice/mammals/mammal.phy")#
#
trait.phy <- sortTraitData(phy=mammal.phy,y=as.matrix(mammal.mass), data.name=c("mean", "sem") ,log.trait=FALSE)#
phy <- trait.phy$phy#
y <- as.matrix(trait.phy$trait[,1])#
errors <- as.numeric(trait.phy$trait[,2])#
splitTime=NULL#
rate.var=FALSE#
mode.order <- c("ou")
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
        alpha <- log(alpha[1])#
        lowerBound <- log(lowerBound[1])#
        upperBound <- log(upperBound[1])#
        if (lambdaEst) {#
        	alpha <- log(alpha[2])#
        lowerBound <- log(lowerBound[2])#
        upperBound <- log(upperBound[2])#
        	anc.loc <- 4#
        	bm.loc <- 3#
        } else {#
        	anc.loc <- 3#
        	bm.loc <- 2#
        }#
        alpha[c(bm.loc, anc.loc)] <- log(c(0.1, 0.1))#
        lowerBound[c(bm.loc, anc.loc)] <- log(c(1e-8, NA))#
        upperBound[c(bm.loc, anc.loc)] <- c(NA,NA)#
      }#
		if(is.ultrametric(phy)) {#
			var.funOU <- function(param) {#
       		if (length(param) != 2) {#
         	 lambda <- 1#
       		 } else {#
          	lambda <- param[2]#
        		}#
	        alpha.int <- param[1]#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        if(!is.ultrametric(phy)) vcv.matrix <- vcv(lambdaPhy)#
	        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix)[[2]])#
	      }#
	     } else {#
	     	var.funOU <- function(param) {#
       		if (!lambdaEst) {#
         	 lambda <- exp(log(1))#
       		 } else {#
          	lambda <- exp(param[2])#
        		}#
	        alpha.int <- exp(param[1])#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        return(transformPhylo.ll(y = y, phy = phy, model="OU", alpha=alpha.int, meserr = meserr, mu = exp(param[anc.loc]), sigma.sq = exp(param[bm.loc]), covPIC = covPIC))#
	      }#
	     }#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
        if(!is.ultrametric(phy)) lambda <- exp(lambda)#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      vcv.matrix <- NULL#
      if (!is.ultrametric(phy)) {#
      	ou.tr <- function(phylo, alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(ancestral.state, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	reml.out <- ou.tr(phy, alpha=exp(vo$par[1]))#
      		}#
#
      if (modelCIs == TRUE) {#
      	if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }#
      if(!is.ultrametric(phy)) {#
      	vo$par <- exp(vo$par)#
      	UCI <- exp(UCI)#
      	LCI <- exp(LCI)#
      	lowerBound[1] <- exp(lowerBound[1])#
        upperBound[1] <- exp(upperBound[1])#
      }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        if (is.ultrametric(phy)) {#
        	ouCurve <- Vectorize(ou.fun)#
        	curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
		} else {#
			ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x, FALSE), from = lowerBound[1], to = lowerBound[2], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        		}
ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}#
        		ouCurve <- Vectorize(ou.fun)
ouCurve <- Vectorize(ou.fun)
ouCurve (lowerBoundp1)
ouCurve (lowerBound[1])
lowerBound[1]
curve(ouCurve(x), from = lowerBound[1], to = lowerBound[2], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
lowerBound[2]
lowerBound[1]
curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
upperBound[1]
ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
model = NULL; modelCIs = TRUE; nodeIDs = NULL; rateType = NULL; minCladeSize = 1; nSplits = 2; splitTime = NULL; boundaryAge = 10; testAge = 1; restrictNode = NULL; lambdaEst = FALSE; acdcScalar = FALSE; branchLabels = NULL; hiddenSpeciation = FALSE; full.phy = NULL; useMean = FALSE; profilePlot = FALSE; lowerBound = NULL; upperBound = NULL; covPIC = TRUE; n.cores = 1; tol = NULL; meserr = NULL; returnPhy = FALSE; print.warnings = FALSE; mode.order=NULL; rate.var=FALSE#
controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5)#
sortedData <- sortTraitData(phy=anolis.tree, y=anolis.data, data.name="Male_SVL", pass.ultrametric=TRUE)#
phy <- sortedData$phy#
male.length <- sortedData$trait#
model <- tolower(model)#
  all.models <- c("bm", "kappa", "lambda", "delta", "ou", "acdc", "psi", "multipsi", "trend", "free", "clade", "tm1", "tm2", "timeslice")#
  if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
  lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
  if (acdcScalar && !is.null(nodeIDs)) upperBound <- -1e-6#
	x <- NULL#
#
acdcScalar = F#
model="modeslice"#
#
mammal.mass <- read.csv("~/Documents/motmotpaper/simulation.time.slice/mammals/mammal_mass.csv", row.names=1)#
mammal.phy <- read.tree("~/Documents/motmotpaper/simulation.time.slice/mammals/mammal.phy")#
#
trait.phy <- sortTraitData(phy=mammal.phy,y=as.matrix(mammal.mass), data.name=c("mean", "sem") ,log.trait=FALSE)#
phy <- trait.phy$phy#
y <- as.matrix(trait.phy$trait[,1])#
errors <- as.numeric(trait.phy$trait[,2])#
splitTime=NULL#
rate.var=FALSE#
mode.order <- c("ou")
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
        alpha <- log(alpha[1])#
        lowerBound <- log(lowerBound[1])#
        upperBound <- log(upperBound[1])#
        if (lambdaEst) {#
        	alpha <- log(alpha[2])#
        lowerBound <- log(lowerBound[2])#
        upperBound <- log(upperBound[2])#
        	anc.loc <- 4#
        	bm.loc <- 3#
        } else {#
        	anc.loc <- 3#
        	bm.loc <- 2#
        }#
        alpha[c(bm.loc, anc.loc)] <- log(c(0.1, 0.1))#
        lowerBound[c(bm.loc, anc.loc)] <- log(c(1e-8, NA))#
        upperBound[c(bm.loc, anc.loc)] <- c(NA,NA)#
      }#
		if(is.ultrametric(phy)) {#
			var.funOU <- function(param) {#
       		if (length(param) != 2) {#
         	 lambda <- 1#
       		 } else {#
          	lambda <- param[2]#
        		}#
	        alpha.int <- param[1]#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        if(!is.ultrametric(phy)) vcv.matrix <- vcv(lambdaPhy)#
	        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix)[[2]])#
	      }#
	     } else {#
	     	var.funOU <- function(param) {#
       		if (!lambdaEst) {#
         	 lambda <- exp(log(1))#
       		 } else {#
          	lambda <- exp(param[2])#
        		}#
	        alpha.int <- exp(param[1])#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        return(transformPhylo.ll(y = y, phy = phy, model="OU", alpha=alpha.int, meserr = meserr, mu = exp(param[anc.loc]), sigma.sq = exp(param[bm.loc]), covPIC = covPIC))#
	      }#
	     }#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
        if(!is.ultrametric(phy)) lambda <- exp(lambda)#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      vcv.matrix <- NULL#
      if (!is.ultrametric(phy)) {#
      	ou.tr <- function(phylo, alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(ancestral.state, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	reml.out <- ou.tr(phy, alpha=exp(vo$par[1]))#
      		}#
#
      if (modelCIs == TRUE) {#
      	if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }#
      if(!is.ultrametric(phy)) {#
      	vo$par <- exp(vo$par)#
      	UCI <- exp(UCI)#
      	LCI <- exp(LCI)#
      	lowerBound[1] <- exp(lowerBound[1])#
        upperBound[1] <- exp(upperBound[1])#
      }
lowerBound
upperBound
is.ultrametric(phy)
ou.fun <- function(param) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}
ouCurve <- Vectorize(ou.fun)
curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
lowerBound[1]
vo$par[1]
param=lowerBound[1]
ll <- ou.tr(phy, alpha=param)[[1]]
ll
ou.tr(phy, alpha=param)
ou.tr <- function(alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(ancestral.state, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	reml.out <- ou.tr(phy, alpha=exp(vo$par[1]))
vo$par
vo$par[1]
reml.out <- ou.tr(alpha=exp(vo$par[1]))
reml.out
ou.tr(alpha=vo$par[1])
vo$par[1]
alpha=vo$par[1]
vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)
motmot:::mu.mean(vcv.matrix, y)[1,1]
mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]
motmot:::sig.sq(mu, vcv.matrix, y)[1,1]
sigma.sq <- motmot:::sig.sq(mu, vcv.matrix, y)[1,1]
reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)
reml.lik
ou.tr <- function(alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(mu, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}
ou.fun <- function(param) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}
ouCurve <- Vectorize(ou.fun)
curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
ll <- ou.tr(alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
ou.fun <- function(param) {#
      			ll <- ou.tr(alpha=param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}
ouCurve <- Vectorize(ou.fun)
curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
lowerBound[1]
upperBound[1]
ouCurve(x)
ou.fun(lowerBound[1])
ou.fun(lowerBound[2])
lambdaPhy
alpha
vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)
mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]
sigma.sq <- motmot:::sig.sq(mu, vcv.matrix, y)[1,1]
reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)
return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))
list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu)
alpha
alpha=1e-8
transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)
vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)
mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]
sigma.sq <- motmot:::sig.sq(mu, vcv.matrix, y)[1,1]
reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)
reml.lik
ou.tr <- function(alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(mu, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}
ou.fun <- function(param) {#
      			ll <- ou.tr(param)[[1]]#
      			return(ll - reml.out[[1]] + 1.92)#
        			}
reml.out[[1]]
reml.out <- ou.tr(alpha=exp(vo$par[1]))
reml.out
reml.out <- ou.tr(alpha=exp(vo$par[1]))
curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
reml.out[[1]]
ll - reml.out[[1]]
ou.fun <- function(param) {#
      			ll <- ou.tr(param)[[1]]#
      			return(ll)#
        			}#
        		ouCurve <- Vectorize(ou.fun)
curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
UCI[1]
model = NULL; modelCIs = TRUE; nodeIDs = NULL; rateType = NULL; minCladeSize = 1; nSplits = 2; splitTime = NULL; boundaryAge = 10; testAge = 1; restrictNode = NULL; lambdaEst = FALSE; acdcScalar = FALSE; branchLabels = NULL; hiddenSpeciation = FALSE; full.phy = NULL; useMean = FALSE; profilePlot = FALSE; lowerBound = NULL; upperBound = NULL; covPIC = TRUE; n.cores = 1; tol = NULL; meserr = NULL; returnPhy = FALSE; print.warnings = FALSE; mode.order=NULL; rate.var=FALSE#
controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5)#
sortedData <- sortTraitData(phy=anolis.tree, y=anolis.data, data.name="Male_SVL", pass.ultrametric=TRUE)#
phy <- sortedData$phy#
male.length <- sortedData$trait#
model <- tolower(model)#
  all.models <- c("bm", "kappa", "lambda", "delta", "ou", "acdc", "psi", "multipsi", "trend", "free", "clade", "tm1", "tm2", "timeslice")#
  if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
  lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
  if (acdcScalar && !is.null(nodeIDs)) upperBound <- -1e-6#
	x <- NULL#
#
acdcScalar = F#
model="modeslice"#
#
mammal.mass <- read.csv("~/Documents/motmotpaper/simulation.time.slice/mammals/mammal_mass.csv", row.names=1)#
mammal.phy <- read.tree("~/Documents/motmotpaper/simulation.time.slice/mammals/mammal.phy")#
#
trait.phy <- sortTraitData(phy=mammal.phy,y=as.matrix(mammal.mass), data.name=c("mean", "sem") ,log.trait=FALSE)#
phy <- trait.phy$phy#
y <- as.matrix(trait.phy$trait[,1])#
errors <- as.numeric(trait.phy$trait[,2])#
splitTime=NULL#
rate.var=FALSE#
mode.order <- c("ou")
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
        alpha <- log(alpha[1])#
        lowerBound <- log(lowerBound[1])#
        upperBound <- log(upperBound[1])#
        if (lambdaEst) {#
        	alpha <- log(alpha[2])#
        lowerBound <- log(lowerBound[2])#
        upperBound <- log(upperBound[2])#
        	anc.loc <- 4#
        	bm.loc <- 3#
        } else {#
        	anc.loc <- 3#
        	bm.loc <- 2#
        }#
        alpha[c(bm.loc, anc.loc)] <- log(c(0.1, 0.1))#
        lowerBound[c(bm.loc, anc.loc)] <- log(c(1e-8, NA))#
        upperBound[c(bm.loc, anc.loc)] <- c(NA,NA)#
      }#
		if(is.ultrametric(phy)) {#
			var.funOU <- function(param) {#
       		if (length(param) != 2) {#
         	 lambda <- 1#
       		 } else {#
          	lambda <- param[2]#
        		}#
	        alpha.int <- param[1]#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        if(!is.ultrametric(phy)) vcv.matrix <- vcv(lambdaPhy)#
	        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix)[[2]])#
	      }#
	     } else {#
	     	var.funOU <- function(param) {#
       		if (!lambdaEst) {#
         	 lambda <- exp(log(1))#
       		 } else {#
          	lambda <- exp(param[2])#
        		}#
	        alpha.int <- exp(param[1])#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        return(transformPhylo.ll(y = y, phy = phy, model="OU", alpha=alpha.int, meserr = meserr, mu = exp(param[anc.loc]), sigma.sq = exp(param[bm.loc]), covPIC = covPIC))#
	      }#
	     }#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
        if(!is.ultrametric(phy)) lambda <- exp(lambda)#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      if (!is.ultrametric(phy)) {#
      	ou.tr <- function(alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(mu, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	reml.out <- ou.tr(alpha=exp(vo$par[1]))#
      		}#
#
      if (modelCIs == TRUE) {#
      	if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }#
      if(!is.ultrametric(phy)) {#
      	vo$par <- exp(vo$par)#
      	UCI <- exp(UCI)#
      	LCI <- exp(LCI)#
      	lowerBound[1] <- exp(lowerBound[1])#
        upperBound[1] <- exp(upperBound[1])#
      }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))
ou.fun <- function(param) {#
      			ll <- ou.tr(param)[[1]]#
      			return(ll)#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
UCI
modelCIs == TRUE
if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = exp(param), nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
LCI
UCI
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
        alpha <- log(alpha[1])#
        lowerBound <- log(lowerBound[1])#
        upperBound <- log(upperBound[1])#
        if (lambdaEst) {#
        	alpha <- log(alpha[2])#
        lowerBound <- log(lowerBound[2])#
        upperBound <- log(upperBound[2])#
        	anc.loc <- 4#
        	bm.loc <- 3#
        } else {#
        	anc.loc <- 3#
        	bm.loc <- 2#
        }#
        alpha[c(bm.loc, anc.loc)] <- log(c(0.1, 0.1))#
        lowerBound[c(bm.loc, anc.loc)] <- log(c(1e-8, NA))#
        upperBound[c(bm.loc, anc.loc)] <- c(NA,NA)#
      }#
		if(is.ultrametric(phy)) {#
			var.funOU <- function(param) {#
       		if (length(param) != 2) {#
         	 lambda <- 1#
       		 } else {#
          	lambda <- param[2]#
        		}#
	        alpha.int <- param[1]#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        if(!is.ultrametric(phy)) vcv.matrix <- vcv(lambdaPhy)#
	        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix)[[2]])#
	      }#
	     } else {#
	     	var.funOU <- function(param) {#
       		if (!lambdaEst) {#
         	 lambda <- exp(log(1))#
       		 } else {#
          	lambda <- exp(param[2])#
        		}#
	        alpha.int <- exp(param[1])#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        return(transformPhylo.ll(y = y, phy = phy, model="OU", alpha=alpha.int, meserr = meserr, mu = exp(param[anc.loc]), sigma.sq = exp(param[bm.loc]), covPIC = covPIC))#
	      }#
	     }#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
        if(!is.ultrametric(phy)) lambda <- exp(lambda)#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      if (!is.ultrametric(phy)) {#
      	ou.tr <- function(alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(mu, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	reml.out <- ou.tr(alpha=exp(vo$par[1]))#
      		}#
#
      if (modelCIs == TRUE) {#
      	if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = exp(param), nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(phy, alpha=param)[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
UCI
exp(          UCI)
if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(alpha=exp(param))[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }
upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)
upper.attempt
UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root
UCI
exp(UCI)
model = NULL; modelCIs = TRUE; nodeIDs = NULL; rateType = NULL; minCladeSize = 1; nSplits = 2; splitTime = NULL; boundaryAge = 10; testAge = 1; restrictNode = NULL; lambdaEst = FALSE; acdcScalar = FALSE; branchLabels = NULL; hiddenSpeciation = FALSE; full.phy = NULL; useMean = FALSE; profilePlot = FALSE; lowerBound = NULL; upperBound = NULL; covPIC = TRUE; n.cores = 1; tol = NULL; meserr = NULL; returnPhy = FALSE; print.warnings = FALSE; mode.order=NULL; rate.var=FALSE#
controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5)#
sortedData <- sortTraitData(phy=anolis.tree, y=anolis.data, data.name="Male_SVL", pass.ultrametric=TRUE)#
phy <- sortedData$phy#
male.length <- sortedData$trait#
model <- tolower(model)#
  all.models <- c("bm", "kappa", "lambda", "delta", "ou", "acdc", "psi", "multipsi", "trend", "free", "clade", "tm1", "tm2", "timeslice")#
  if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
  lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
  if (acdcScalar && !is.null(nodeIDs)) upperBound <- -1e-6#
	x <- NULL#
#
acdcScalar = F#
model="modeslice"#
#
mammal.mass <- read.csv("~/Documents/motmotpaper/simulation.time.slice/mammals/mammal_mass.csv", row.names=1)#
mammal.phy <- read.tree("~/Documents/motmotpaper/simulation.time.slice/mammals/mammal.phy")#
#
trait.phy <- sortTraitData(phy=mammal.phy,y=as.matrix(mammal.mass), data.name=c("mean", "sem") ,log.trait=FALSE)#
phy <- trait.phy$phy#
y <- as.matrix(trait.phy$trait[,1])#
errors <- as.numeric(trait.phy$trait[,2])#
splitTime=NULL#
rate.var=FALSE#
mode.order <- c("ou")
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
        alpha <- log(alpha[1])#
        lowerBound <- log(lowerBound[1])#
        upperBound <- log(upperBound[1])#
        if (lambdaEst) {#
        	alpha <- log(alpha[2])#
        lowerBound <- log(lowerBound[2])#
        upperBound <- log(upperBound[2])#
        	anc.loc <- 4#
        	bm.loc <- 3#
        } else {#
        	anc.loc <- 3#
        	bm.loc <- 2#
        }#
        alpha[c(bm.loc, anc.loc)] <- log(c(0.1, 0.1))#
        lowerBound[c(bm.loc, anc.loc)] <- log(c(1e-8, NA))#
        upperBound[c(bm.loc, anc.loc)] <- c(NA,NA)#
      }#
		if(is.ultrametric(phy)) {#
			var.funOU <- function(param) {#
       		if (length(param) != 2) {#
         	 lambda <- 1#
       		 } else {#
          	lambda <- param[2]#
        		}#
	        alpha.int <- param[1]#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        if(!is.ultrametric(phy)) vcv.matrix <- vcv(lambdaPhy)#
	        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix)[[2]])#
	      }#
	     } else {#
	     	var.funOU <- function(param) {#
       		if (!lambdaEst) {#
         	 lambda <- exp(log(1))#
       		 } else {#
          	lambda <- exp(param[2])#
        		}#
	        alpha.int <- exp(param[1])#
	        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
	        return(transformPhylo.ll(y = y, phy = phy, model="OU", alpha=alpha.int, meserr = meserr, mu = exp(param[anc.loc]), sigma.sq = exp(param[bm.loc]), covPIC = covPIC))#
	      }#
	     }#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
        if(!is.ultrametric(phy)) lambda <- exp(lambda)#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      if (!is.ultrametric(phy)) {#
      	ou.tr <- function(alpha) {#
	      	vcv.matrix <- transformPhylo(y = y, phy = lambdaPhy, alpha = alpha, nodeIDs = nodeIDs, model = "OU", meserr = meserr)#
    	  		mu <- motmot:::mu.mean(vcv.matrix, y)[1,1]#
    		  	sigma.sq <- motmot:::sig.sq(mu, vcv.matrix, y)[1,1]#
      		reml.lik <- dmvnorm(y[,1], mean=rep(mu, ncol(vcv.matrix)), sigma=vcv.matrix * sigma.sq, log=TRUE)#
      		return(list(reml.lik=reml.lik, reml.sigma.sq=sigma.sq, reml.mu=mu))#
      		}#
      	reml.out <- ou.tr(alpha=exp(vo$par[1]))#
      		}#
#
      if (modelCIs == TRUE) {#
      	if (is.ultrametric(phy)) {#
      		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC)$logLikelihood#
      			if (chiSq) {#
      				return(ll - vo$value + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        } else {#
        		ou.fun <- function(param, chiSq = TRUE) {#
      			ll <- ou.tr(alpha=exp(param))[[1]]#
      			if (chiSq) {#
      				return(ll - reml.out[[1]] + 1.92)#
      			} else {#
      				return(ll)#
      				}#
      			}#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
if(!is.ultrametric(phy)) {#
      	vo$par <- exp(vo$par)#
      	UCI <- exp(UCI)#
      	LCI <- exp(LCI)#
      	lowerBound[1] <- exp(lowerBound[1])#
        upperBound[1] <- exp(upperBound[1])#
      }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        if (is.ultrametric(phy)) {#
        	ouCurve <- Vectorize(ou.fun)#
        	curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
		} else {#
			ou.fun <- function(param) {#
      			ll <- ou.tr(param)[[1]]#
      			return(ll)#
        			}#
        		ouCurve <- Vectorize(ou.fun)#
        		curve(ouCurve(x), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        	if (modelCIs) abline(v = c(LCI[1], vo$par[1], UCI[1]), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        		}
out <- list()
out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }
out
vo$value[1] <- reml.out[[1]]
out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }
out
out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }#
      if(is.ultrametric(phy)) {#
      	ouPhy <- transformPhylo(y = y, phy = lambdaPhy, model = "OU", alpha = vo$par[1], meserr = meserr)#
      	out$brownianVariance <- likTraitPhylo(y = y, phy = ouPhy, covPIC = covPIC)$brownianVariance#
      	out$root.state <- apply(y, 2, function(col.y) as.numeric(as.numeric(ace(col.y, phy = ouPhy, method = "pic")[[1]][1])))#
      } else {#
      	ouPhy <- vcv.matrix#
      	out$brownianVariance <- sigma.sq#
      	out$root.state <- mu#
      }
out
param <- 3#
      if (lambdaEst) {#
        out$lambda <- vo$par[2]#
        param <- 4#
      }#
      out$AIC <- aic.fun(out$MaximumLikelihood, param)#
      out$AICc <- aicc.fun(out$MaximumLikelihood, param, Ntip(phy))
if (returnPhy) out$ouPhy <- ouPhy
out
acdcScalar=TRUE
lambdaEst=FALSE
!acdcScalar && lambdaEst || acdcScalar && !lambdaEst
acdcScalar=F
!acdcScalar && lambdaEst || acdcScalar && !lambdaEst
lambdaEst=R
lambdaEst=T
!acdcScalar && lambdaEst || acdcScalar && !lambdaEst
acdcScalar=T
!acdcScalar && lambdaEst || acdcScalar && !lambdaEst
match(mode.order, c("bm", "ou", "kappa", "acdc"))
mode.order=c("bm", "ou")
match(mode.order, c("bm", "ou", "kappa", "acdc"))
mode.order="trend"
match(mode.order, c("bm", "ou", "kappa", "acdc"))
if(any(is.na(match(mode.order, c("bm", "ou", "kappa", "acdc"))))) stop("mode.order must be one of 'bm', 'ou', 'kappa', or 'acdc'")
if(any(is.na(match(mode.order, c("bm", "ou", "kappa", "acdc"))))) stop("mode.order must be a combination of 'bm', 'ou', 'kappa', and/or 'acdc'")
data(anolis.tree)
library(motmot)
data(anolis.tree)
phy=anolis.tree
model="bm"
model <- tolower(model)#
	all.models <- c("bm", "trend", "kappa", "lambda", "delta", "free", "clade", "ou", "acdc", "psi", "multipsi", "timeslice", "mixedrate")#
	if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))
y.sim.function <- function(phy, return.node=FALSE) {	#
		lengths <- phy$edge.length#
		empty.mat <- matrix(NA, nrow=nrow(phy$edge), ncol=2)#
		start.nodes <- which(phy$edge[,1] == Ntip(phy) + 1)#
		empty.mat[start.nodes,1] <- rnorm(1)#
		while(length(start.nodes) != 0) {#
			next.node <- phy$edge[start.nodes,2]#
			var.to.add <- rnorm(length(start.nodes), sd=sqrt(lengths[start.nodes]))#
			empty.mat[start.nodes,2] <- empty.mat[start.nodes,1] + var.to.add#
			start.nodes.int <- c()#
			for(xx in 1:length(next.node)) {#
				n.n <- which(phy$edge[,1] == next.node[xx])#
				empty.mat[n.n,1] <- empty.mat[start.nodes[xx], 2]#
				}#
			start.nodes <- intersect(which(complete.cases(empty.mat[, 1])), which(!complete.cases(empty.mat[, 2])))#
			}	#
		tips <- which(phy$edge[, 2] <= Ntip(phy))#
		y.out <- list()#
		y.out$y <- matrix(empty.mat[tips, 2], dimnames=list(phy$tip.label))#
		if(return.node) y.out$all.nodes <- empty.mat#
		return(y.out)#
		}
n=1
transformPhy <- phy#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					ydum <- sapply(1:n, function(ix) y.sim.function(phy))
ydum
return.node=TRUE
ydum <- sapply(1:n, function(ix) y.sim.function(phy, return.node=return.node))
ydum
ydum <- lapply(1:n, function(ix) y.sim.function(phy, return.node=return.node))
ydum
sapply(ydum, function(re) re[[1]])
ydum.all <- lapply(1:n, function(ix) y.sim.function(phy, return.node=return.node))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label
ydum
#' @title Phylogenetic tree transformations#
#' @description Simulates trait data on a tree using a specified model of evolution (see details).#
#' @param phy An object of class \code{phylo} (see \pkg{ape}).#
#' @param n Number of simulations#
#' @param x Vector, matrix or data.frame (with taxon names as names or rownames) of categories for each species. Only applicable if model="mixedRate" #
#' @param model The model of trait evolution (see details).#
#' @param kappa Value of kappa transform.#
#' @param lambda Value of lambda transform.#
#' @param delta Value of delta transform.#
#' @param alpha Value of alpha (OU) transform.#
#' @param psi Value of psi transform.  Note that 'original nodes' from the full phylogeny can be included as an element on the phylogeny (e.g., phy$orig.node) as well as estimates of 'hidden' speciation (e.g., phy$hidden.speciation) if estimates of extinction (mu) are > 0.#
#' @param lambda.sp Estimate of speciation (lambda) for the psi models#
#' @param splitTime A split time (measured from the present, or most recent species) at which a shift in the rate occurs for the "timeSlice" model#
#' @param timeRates The rates (from ancient to recent) for the timeSlice model#
#' @param nodeIDs Integer - ancestral nodes of clades.#
#' @param rateType If model="clade", a vector specifying if rate shift occurs in a clade ("clade") or on the single branch leading to a clade ("branch").#
#' @param acdcRate Value of ACDC transform.#
#' @param trend value of the expectation mean change through time#
#' @param trend.anc.state the expected ancestal state for the trend model (default is 0)#
#' @param branchLabels Branches on which different psi parameters are estimated in the "multipsi" model.#
#' @param branchRates Numeric vector specifying relative rates for individual branches#
#' @param cladeRates Numeric vector specifying telative rates for clades.#
#' @param rate a vector of relative rate parameters. The length of the vector is equal to the number of rates being estimated. #
#' @param group.means a vector of the relative difference in means between rate categories, expressed as a scalar applied to the expected standard deviation (see Ricklefs 2006)#
#' @param mode.order The order of modes for the 'modeslice' model. Any combination of 'BM', 'OU', 'acdc', and 'kappa'#
#' @param cladeRates Numeric vector specifying telative rates for clades or logical to indicate scalar is included in the 'modeslice' model (the scalar is included in the mode.param argument with the 'modeslice' model).#
#' @param acdcScalar Logical.For nested EB rate model, simultaneously estimated a rate scalar alongside EB model. Default=FALSE. Only applicable to 'nested mode' and 'modeSlice' models.#
#' @param rate.var Allows rate variation in BM modes in the 'modeslice' model#
#' @return Returns a matrix of simulated dated with taxon names as rownames (number of columns=n).#
#' @references Ricklefs RE. 2006. Time, species, and the generation of trait variation in clades. Systematic Biology 55, 151-159.#
#' @references Ricklefs RE. 2006. Thomas GH, Meiri S, & Phillimore AB. 2009. Body size diversification in Anolis: novel environments and island effects. Evolution 63, 2017-2030#
#' @author Gavin Thomas, Mark Puttick#
#' @seealso \code{\link{transformPhylo.ML}}, \code{\link{transformPhylo.ll}}, \code{\link{transformPhylo}}, \code{\link{transformPhylo.MCMC}}#
#' @import mvtnorm#
#' @examples#
#' data(anolis.tree)#
#' data(anolis.data)#
#' #
#' # Simulate 10 sets of data with kappa=0.1 using the anolis tree#
#' sim.dat1 <- transformPhylo.sim(phy=anolis.tree, n=10, model="kappa", kappa=0.1)#
#' #
#' # Simulate 10 sets of data where rates and means differ between to the categories defined by "x"#
#' x <- anolis.data$geo_ecomorph#
#' names(x) <-  rownames(anolis.data)#
#' sim.dat2 <- transformPhylo.sim(phy=anolis.tree, n=10, x=x, model="mixedRate", rate=c(1,1,2,4),#
#' group.means=c(0,5,0,0))#
#' @export#
#
transformPhylo.sim <- function(phy, n=1, x=NULL, model=NULL, kappa=NULL, lambda=NULL, delta=NULL, alpha=NULL, psi=NULL, acdcRate=NULL, lambda.sp = NULL, trend=NULL, trend.anc.state=0, nodeIDs=NULL, rateType=NULL, cladeRates=NULL, branchRates=NULL, rate=NULL, group.means=NULL, splitTime=NULL, timeRates=NULL, branchLabels = NULL) {#
	  model <- tolower(model)#
	all.models <- c("bm", "trend", "kappa", "lambda", "delta", "free", "clade", "ou", "acdc", "psi", "multipsi", "timeslice", "mixedrate")#
	if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
	y.sim.function <- function(phy, return.node=FALSE) {	#
		lengths <- phy$edge.length#
		empty.mat <- matrix(NA, nrow=nrow(phy$edge), ncol=2)#
		start.nodes <- which(phy$edge[,1] == Ntip(phy) + 1)#
		empty.mat[start.nodes,1] <- rnorm(1)#
		while(length(start.nodes) != 0) {#
			next.node <- phy$edge[start.nodes,2]#
			var.to.add <- rnorm(length(start.nodes), sd=sqrt(lengths[start.nodes]))#
			empty.mat[start.nodes,2] <- empty.mat[start.nodes,1] + var.to.add#
			start.nodes.int <- c()#
			for(xx in 1:length(next.node)) {#
				n.n <- which(phy$edge[,1] == next.node[xx])#
				empty.mat[n.n,1] <- empty.mat[start.nodes[xx], 2]#
				}#
			start.nodes <- intersect(which(complete.cases(empty.mat[, 1])), which(!complete.cases(empty.mat[, 2])))#
			}	#
		tips <- which(phy$edge[, 2] <= Ntip(phy))#
		y.out <- list()#
		y.out$y <- matrix(empty.mat[tips, 2], dimnames=list(phy$tip.label))#
		if(return.node) y.out$all.nodes <- empty.mat#
		return(y.out)#
		}#
#
	switch(model,		  #
		   "bm" = {#
					transformPhy <- phy#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(phy, return.node=return.node))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(return.node) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
			 "trend" = {#
					transformPhy <- phy#
					phyMat <- VCV.array(transformPhy)#
					attr(phyMat, "class") <- "matrix"#
					tip.distance <- diag(vcv(transformPhy))#
					trend.mean <- trend.anc.state + (tip.distance * trend)#
					ydum <- as.matrix(t(mvtnorm::rmvnorm(n, mean=trend.mean, sigma = phyMat)))#
					rownames(ydum) <- rownames(phyMat)#
					},#
		   "kappa" = {#
					transformPhy <- transformPhylo(phy=phy, model="kappa", kappa=kappa, nodeIDs=nodeIDs)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "lambda" = {#
					transformPhy <- transformPhylo(phy=phy, model="lambda", lambda=lambda)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "delta" = {#
					transformPhy <- transformPhylo(phy=phy, model="delta", delta=delta, nodeIDs=nodeIDs)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "free" = {#
					transformPhy <- transformPhylo(phy=phy, model="free", branchRates=branchRates)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label	#
					},#
		   "clade" = {#
					transformPhy <- transformPhylo(phy=phy, model="clade", nodeIDs=nodeIDs, cladeRates=cladeRates, rateType=rateType)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "ou" = {#
		   			if (!is.ultrametric(phy)) {#
      			        cophenetic.dist <- cophenetic.phylo(phy)#
      			        vcv.matrix <- VCV.array(vcv.matrix)#
      			        phyMat <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs, cophenetic.dist=cophenetic.dist, vcv.matrix=vcv.matrix)#
      			        ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
      			        rownames(ydum) <- rownames(phyMat)#
      			        } else {#
      			        transformPhy <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs)#
						# phyMat <- VCV.array(transformPhy)#
						# attr(phyMat, "class") <- "matrix"#
						# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
						# rownames(ydum) <- rownames(phyMat)#
						ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
						rownames(ydum) <- phy$tip.label#
						}#
					},#
			"acdc" = {#
					transformPhy <- transformPhylo(phy=phy, model="ACDC", acdcRate=acdcRate, nodeIDs=nodeIDs, cladeRates=cladeRates)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "psi" = {#
					transformPhy <- transformPhylo(phy = phy, model = "psi", psi = psi, lambda.sp = lambda.sp)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
			"multipsi" = {#
       				transformPhy <- transformPhylo(phy = phy, model = "multipsi", psi = psi, lambda.sp = lambda.sp, branchLabels = branchLabels)#
       				# phyMat <- VCV.array(transformPhy)#
       				# attr(phyMat, "class") <- "matrix"#
        				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
        				# rownames(ydum) <- rownames(phyMat)#
        				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
    				},#
			"timeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="timeSlice", splitTime=splitTime, timeRates=timeRates)#
		   		# phyMat <- VCV.array(transformPhy)#
				# attr(phyMat, "class") <- "matrix"#
				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
				# rownames(ydum) <- rownames(phyMat)#
				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
				rownames(ydum) <- phy$tip.label#
		   		} ,#
		   	"modeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="modeSlice", mode.order=mode.order, splitTime=splitTime, cladeRates=cladeRates, rate.var=rate.var)#
		   		# phyMat <- VCV.array(transformPhy)#
				# attr(phyMat, "class") <- "matrix"#
				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
				# rownames(ydum) <- rownames(phyMat)#
				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
				rownames(ydum) <- phy$tip.label#
		   		} ,#
#
			"mixedrate" = {#
        			x <- as.matrix(x)#
		        dat <- data.frame(x = x, y = rep(0, length(x[, 1])))#
		        rateData <- as.rateData(y = "y", x = "x", rateMatrix = NULL, phy = phy, data = dat)#
		        V <- transformRateMatrix(rateData, rate = rate)#
		        expect.sd <- sqrt(mean(V[upper.tri(V)]))#
		        if (is.null(group.means)) {#
		            # ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = (V))))#
		            # rownames(ydum) <- rownames(V)#
		            ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
		        } else {#
		            x.means <- unique(rateData$x)#
		            n.means <- length(x.means)#
		            samp.means <- rep(NA, length(rateData$x))#
		            ydum <- vector(mode = "list", length = length(group.means))#
		            for (i in 1:n.means) {#
		                samp.means[which(rateData$x == (i - 1))] <- rep(0 + (expect.sd * group.means[i]), length(which(rateData$x == (i - 1))))#
		            }#
		            ydum <- as.matrix(t(rmvnorm(n, mean = samp.means, sigma = (V))))#
		            rownames(ydum) <- rownames(V)#
		       		}#
		       	}#
		   )#
	return(ydum)#
}
#' @title Phylogenetic tree transformations#
#' @description Simulates trait data on a tree using a specified model of evolution (see details).#
#' @param phy An object of class \code{phylo} (see \pkg{ape}).#
#' @param n Number of simulations#
#' @param x Vector, matrix or data.frame (with taxon names as names or rownames) of categories for each species. Only applicable if model="mixedRate" #
#' @param model The model of trait evolution (see details).#
#' @param returnNodes Logical. If TRUE, alongside the tip values all node values are returned corresponding to APE's edge.matrix for the tree.#
#' @param kappa Value of kappa transform.#
#' @param lambda Value of lambda transform.#
#' @param delta Value of delta transform.#
#' @param alpha Value of alpha (OU) transform.#
#' @param psi Value of psi transform.  Note that 'original nodes' from the full phylogeny can be included as an element on the phylogeny (e.g., phy$orig.node) as well as estimates of 'hidden' speciation (e.g., phy$hidden.speciation) if estimates of extinction (mu) are > 0.#
#' @param lambda.sp Estimate of speciation (lambda) for the psi models#
#' @param splitTime A split time (measured from the present, or most recent species) at which a shift in the rate occurs for the "timeSlice" model#
#' @param timeRates The rates (from ancient to recent) for the timeSlice model#
#' @param nodeIDs Integer - ancestral nodes of clades.#
#' @param rateType If model="clade", a vector specifying if rate shift occurs in a clade ("clade") or on the single branch leading to a clade ("branch").#
#' @param acdcRate Value of ACDC transform.#
#' @param trend value of the expectation mean change through time#
#' @param trend.anc.state the expected ancestal state for the trend model (default is 0)#
#' @param branchLabels Branches on which different psi parameters are estimated in the "multipsi" model.#
#' @param branchRates Numeric vector specifying relative rates for individual branches#
#' @param cladeRates Numeric vector specifying telative rates for clades.#
#' @param rate a vector of relative rate parameters. The length of the vector is equal to the number of rates being estimated. #
#' @param group.means a vector of the relative difference in means between rate categories, expressed as a scalar applied to the expected standard deviation (see Ricklefs 2006)#
#' @param mode.order The order of modes for the 'modeslice' model. Any combination of 'BM', 'OU', 'acdc', and 'kappa'#
#' @param cladeRates Numeric vector specifying telative rates for clades or logical to indicate scalar is included in the 'modeslice' model (the scalar is included in the mode.param argument with the 'modeslice' model).#
#' @param acdcScalar Logical.For nested EB rate model, simultaneously estimated a rate scalar alongside EB model. Default=FALSE. Only applicable to 'nested mode' and 'modeSlice' models.#
#' @param rate.var Allows rate variation in BM modes in the 'modeslice' model#
#' @return Returns a matrix of simulated dated with taxon names as rownames (number of columns=n).#
#' @references Ricklefs RE. 2006. Time, species, and the generation of trait variation in clades. Systematic Biology 55, 151-159.#
#' @references Ricklefs RE. 2006. Thomas GH, Meiri S, & Phillimore AB. 2009. Body size diversification in Anolis: novel environments and island effects. Evolution 63, 2017-2030#
#' @author Gavin Thomas, Mark Puttick#
#' @seealso \code{\link{transformPhylo.ML}}, \code{\link{transformPhylo.ll}}, \code{\link{transformPhylo}}, \code{\link{transformPhylo.MCMC}}#
#' @import mvtnorm#
#' @examples#
#' data(anolis.tree)#
#' data(anolis.data)#
#' #
#' # Simulate 10 sets of data with kappa=0.1 using the anolis tree#
#' sim.dat1 <- transformPhylo.sim(phy=anolis.tree, n=10, model="kappa", kappa=0.1)#
#' #
#' # Simulate 10 sets of data where rates and means differ between to the categories defined by "x"#
#' x <- anolis.data$geo_ecomorph#
#' names(x) <-  rownames(anolis.data)#
#' sim.dat2 <- transformPhylo.sim(phy=anolis.tree, n=10, x=x, model="mixedRate", rate=c(1,1,2,4),#
#' group.means=c(0,5,0,0))#
#' @export#
#
transformPhylo.sim <- function(phy, n=1, x=NULL, model=NULL, returnNodes=FALSE, kappa=NULL, lambda=NULL, delta=NULL, alpha=NULL, psi=NULL, acdcRate=NULL, lambda.sp = NULL, trend=NULL, trend.anc.state=0, nodeIDs=NULL, rateType=NULL, cladeRates=NULL, branchRates=NULL, rate=NULL, group.means=NULL, splitTime=NULL, timeRates=NULL, branchLabels = NULL) {#
	  model <- tolower(model)#
	all.models <- c("bm", "trend", "kappa", "lambda", "delta", "free", "clade", "ou", "acdc", "psi", "multipsi", "timeslice", "mixedrate")#
	if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
	y.sim.function <- function(phy, return.node=FALSE) {	#
		lengths <- phy$edge.length#
		empty.mat <- matrix(NA, nrow=nrow(phy$edge), ncol=2)#
		start.nodes <- which(phy$edge[,1] == Ntip(phy) + 1)#
		empty.mat[start.nodes,1] <- rnorm(1)#
		while(length(start.nodes) != 0) {#
			next.node <- phy$edge[start.nodes,2]#
			var.to.add <- rnorm(length(start.nodes), sd=sqrt(lengths[start.nodes]))#
			empty.mat[start.nodes,2] <- empty.mat[start.nodes,1] + var.to.add#
			start.nodes.int <- c()#
			for(xx in 1:length(next.node)) {#
				n.n <- which(phy$edge[,1] == next.node[xx])#
				empty.mat[n.n,1] <- empty.mat[start.nodes[xx], 2]#
				}#
			start.nodes <- intersect(which(complete.cases(empty.mat[, 1])), which(!complete.cases(empty.mat[, 2])))#
			}	#
		tips <- which(phy$edge[, 2] <= Ntip(phy))#
		y.out <- list()#
		y.out$y <- matrix(empty.mat[tips, 2], dimnames=list(phy$tip.label))#
		if(return.node) y.out$all.nodes <- empty.mat#
		return(y.out)#
		}#
#
	switch(model,		  #
		   "bm" = {#
					transformPhy <- phy#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(phy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
			 "trend" = {#
					transformPhy <- phy#
					phyMat <- VCV.array(transformPhy)#
					attr(phyMat, "class") <- "matrix"#
					tip.distance <- diag(vcv(transformPhy))#
					trend.mean <- trend.anc.state + (tip.distance * trend)#
					ydum <- as.matrix(t(mvtnorm::rmvnorm(n, mean=trend.mean, sigma = phyMat)))#
					rownames(ydum) <- rownames(phyMat)#
					},#
		   "kappa" = {#
					transformPhy <- transformPhylo(phy=phy, model="kappa", kappa=kappa, nodeIDs=nodeIDs)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "lambda" = {#
					transformPhy <- transformPhylo(phy=phy, model="lambda", lambda=lambda)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "delta" = {#
					transformPhy <- transformPhylo(phy=phy, model="delta", delta=delta, nodeIDs=nodeIDs)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "free" = {#
					transformPhy <- transformPhylo(phy=phy, model="free", branchRates=branchRates)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label	#
					},#
		   "clade" = {#
					transformPhy <- transformPhylo(phy=phy, model="clade", nodeIDs=nodeIDs, cladeRates=cladeRates, rateType=rateType)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "ou" = {#
		   			if (!is.ultrametric(phy)) {#
      			        cophenetic.dist <- cophenetic.phylo(phy)#
      			        vcv.matrix <- VCV.array(vcv.matrix)#
      			        phyMat <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs, cophenetic.dist=cophenetic.dist, vcv.matrix=vcv.matrix)#
      			        ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
      			        rownames(ydum) <- rownames(phyMat)#
      			        } else {#
      			        transformPhy <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs)#
						# phyMat <- VCV.array(transformPhy)#
						# attr(phyMat, "class") <- "matrix"#
						# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
						# rownames(ydum) <- rownames(phyMat)#
						ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
						rownames(ydum) <- phy$tip.label#
						}#
					},#
			"acdc" = {#
					transformPhy <- transformPhylo(phy=phy, model="ACDC", acdcRate=acdcRate, nodeIDs=nodeIDs, cladeRates=cladeRates)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "psi" = {#
					transformPhy <- transformPhylo(phy = phy, model = "psi", psi = psi, lambda.sp = lambda.sp)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
			"multipsi" = {#
       				transformPhy <- transformPhylo(phy = phy, model = "multipsi", psi = psi, lambda.sp = lambda.sp, branchLabels = branchLabels)#
       				# phyMat <- VCV.array(transformPhy)#
       				# attr(phyMat, "class") <- "matrix"#
        				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
        				# rownames(ydum) <- rownames(phyMat)#
        				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
    				},#
			"timeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="timeSlice", splitTime=splitTime, timeRates=timeRates)#
		   		# phyMat <- VCV.array(transformPhy)#
				# attr(phyMat, "class") <- "matrix"#
				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
				# rownames(ydum) <- rownames(phyMat)#
				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
				rownames(ydum) <- phy$tip.label#
		   		} ,#
		   	"modeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="modeSlice", mode.order=mode.order, splitTime=splitTime, cladeRates=cladeRates, rate.var=rate.var)#
		   		# phyMat <- VCV.array(transformPhy)#
				# attr(phyMat, "class") <- "matrix"#
				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
				# rownames(ydum) <- rownames(phyMat)#
				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
				rownames(ydum) <- phy$tip.label#
		   		} ,#
#
			"mixedrate" = {#
        			x <- as.matrix(x)#
		        dat <- data.frame(x = x, y = rep(0, length(x[, 1])))#
		        rateData <- as.rateData(y = "y", x = "x", rateMatrix = NULL, phy = phy, data = dat)#
		        V <- transformRateMatrix(rateData, rate = rate)#
		        expect.sd <- sqrt(mean(V[upper.tri(V)]))#
		        if (is.null(group.means)) {#
		            # ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = (V))))#
		            # rownames(ydum) <- rownames(V)#
		            ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
		        } else {#
		            x.means <- unique(rateData$x)#
		            n.means <- length(x.means)#
		            samp.means <- rep(NA, length(rateData$x))#
		            ydum <- vector(mode = "list", length = length(group.means))#
		            for (i in 1:n.means) {#
		                samp.means[which(rateData$x == (i - 1))] <- rep(0 + (expect.sd * group.means[i]), length(which(rateData$x == (i - 1))))#
		            }#
		            ydum <- as.matrix(t(rmvnorm(n, mean = samp.means, sigma = (V))))#
		            rownames(ydum) <- rownames(V)#
		       		}#
		       	}#
		   )#
	return(ydum)#
}
#' @title Phylogenetic tree transformations#
#' @description Simulates trait data on a tree using a specified model of evolution (see details).#
#' @param phy An object of class \code{phylo} (see \pkg{ape}).#
#' @param n Number of simulations#
#' @param x Vector, matrix or data.frame (with taxon names as names or rownames) of categories for each species. Only applicable if model="mixedRate" #
#' @param model The model of trait evolution (see details).#
#' @param returnNodes Logical. If TRUE, alongside the tip values all node values are returned corresponding to APE's edge.matrix for the tree.#
#' @param kappa Value of kappa transform.#
#' @param lambda Value of lambda transform.#
#' @param delta Value of delta transform.#
#' @param alpha Value of alpha (OU) transform.#
#' @param psi Value of psi transform.  Note that 'original nodes' from the full phylogeny can be included as an element on the phylogeny (e.g., phy$orig.node) as well as estimates of 'hidden' speciation (e.g., phy$hidden.speciation) if estimates of extinction (mu) are > 0.#
#' @param lambda.sp Estimate of speciation (lambda) for the psi models#
#' @param splitTime A split time (measured from the present, or most recent species) at which a shift in the rate occurs for the "timeSlice" model#
#' @param timeRates The rates (from ancient to recent) for the timeSlice model#
#' @param nodeIDs Integer - ancestral nodes of clades.#
#' @param rateType If model="clade", a vector specifying if rate shift occurs in a clade ("clade") or on the single branch leading to a clade ("branch").#
#' @param acdcRate Value of ACDC transform.#
#' @param trend value of the expectation mean change through time#
#' @param trend.anc.state the expected ancestal state for the trend model (default is 0)#
#' @param branchLabels Branches on which different psi parameters are estimated in the "multipsi" model.#
#' @param branchRates Numeric vector specifying relative rates for individual branches#
#' @param cladeRates Numeric vector specifying telative rates for clades.#
#' @param rate a vector of relative rate parameters. The length of the vector is equal to the number of rates being estimated. #
#' @param group.means a vector of the relative difference in means between rate categories, expressed as a scalar applied to the expected standard deviation (see Ricklefs 2006)#
#' @param mode.order The order of modes for the 'modeslice' model. Any combination of 'BM', 'OU', 'acdc', and 'kappa'#
#' @param cladeRates Numeric vector specifying telative rates for clades or logical to indicate scalar is included in the 'modeslice' model (the scalar is included in the mode.param argument with the 'modeslice' model).#
#' @param acdcScalar Logical.For nested EB rate model, simultaneously estimated a rate scalar alongside EB model. Default=FALSE. Only applicable to 'nested mode' and 'modeSlice' models.#
#' @param rate.var Allows rate variation in BM modes in the 'modeslice' model#
#' @return Returns a matrix of simulated dated with taxon names as rownames (number of columns=n).#
#' @references Ricklefs RE. 2006. Time, species, and the generation of trait variation in clades. Systematic Biology 55, 151-159.#
#' @references Ricklefs RE. 2006. Thomas GH, Meiri S, & Phillimore AB. 2009. Body size diversification in Anolis: novel environments and island effects. Evolution 63, 2017-2030#
#' @author Gavin Thomas, Mark Puttick#
#' @seealso \code{\link{transformPhylo.ML}}, \code{\link{transformPhylo.ll}}, \code{\link{transformPhylo}}, \code{\link{transformPhylo.MCMC}}#
#' @import mvtnorm#
#' @examples#
#' data(anolis.tree)#
#' data(anolis.data)#
#' #
#' # Simulate 10 sets of data with kappa=0.1 using the anolis tree#
#' sim.dat1 <- transformPhylo.sim(phy=anolis.tree, n=10, model="kappa", kappa=0.1)#
#' #
#' # Simulate 10 sets of data where rates and means differ between to the categories defined by "x"#
#' x <- anolis.data$geo_ecomorph#
#' names(x) <-  rownames(anolis.data)#
#' sim.dat2 <- transformPhylo.sim(phy=anolis.tree, n=10, x=x, model="mixedRate", rate=c(1,1,2,4),#
#' group.means=c(0,5,0,0))#
#' @export#
#
transformPhylo.sim <- function(phy, n=1, x=NULL, model=NULL, returnNodes=FALSE, kappa=NULL, lambda=NULL, delta=NULL, alpha=NULL, psi=NULL, acdcRate=NULL, lambda.sp = NULL, trend=NULL, trend.anc.state=0, nodeIDs=NULL, rateType=NULL, cladeRates=NULL, branchRates=NULL, rate=NULL, group.means=NULL, splitTime=NULL, timeRates=NULL, branchLabels = NULL) {#
	  model <- tolower(model)#
	all.models <- c("bm", "trend", "kappa", "lambda", "delta", "free", "clade", "ou", "acdc", "psi", "multipsi", "timeslice", "mixedrate")#
	if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
	y.sim.function <- function(phy, return.node=FALSE) {	#
		lengths <- phy$edge.length#
		empty.mat <- matrix(NA, nrow=nrow(phy$edge), ncol=2)#
		start.nodes <- which(phy$edge[,1] == Ntip(phy) + 1)#
		empty.mat[start.nodes,1] <- rnorm(1)#
		while(length(start.nodes) != 0) {#
			next.node <- phy$edge[start.nodes,2]#
			var.to.add <- rnorm(length(start.nodes), sd=sqrt(lengths[start.nodes]))#
			empty.mat[start.nodes,2] <- empty.mat[start.nodes,1] + var.to.add#
			start.nodes.int <- c()#
			for(xx in 1:length(next.node)) {#
				n.n <- which(phy$edge[,1] == next.node[xx])#
				empty.mat[n.n,1] <- empty.mat[start.nodes[xx], 2]#
				}#
			start.nodes <- intersect(which(complete.cases(empty.mat[, 1])), which(!complete.cases(empty.mat[, 2])))#
			}	#
		tips <- which(phy$edge[, 2] <= Ntip(phy))#
		y.out <- list()#
		y.out$y <- matrix(empty.mat[tips, 2], dimnames=list(phy$tip.label))#
		if(return.node) y.out$all.nodes <- empty.mat#
		return(y.out)#
		}#
#
	switch(model,		  #
		   "bm" = {#
					transformPhy <- phy#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(phy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
			 "trend" = {#
					transformPhy <- phy#
					phyMat <- VCV.array(transformPhy)#
					attr(phyMat, "class") <- "matrix"#
					tip.distance <- diag(vcv(transformPhy))#
					trend.mean <- trend.anc.state + (tip.distance * trend)#
					ydum <- as.matrix(t(mvtnorm::rmvnorm(n, mean=trend.mean, sigma = phyMat)))#
					rownames(ydum) <- rownames(phyMat)#
					},#
		   "kappa" = {#
					transformPhy <- transformPhylo(phy=phy, model="kappa", kappa=kappa, nodeIDs=nodeIDs)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "lambda" = {#
					transformPhy <- transformPhylo(phy=phy, model="lambda", lambda=lambda)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "delta" = {#
					transformPhy <- transformPhylo(phy=phy, model="delta", delta=delta, nodeIDs=nodeIDs)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "free" = {#
					transformPhy <- transformPhylo(phy=phy, model="free", branchRates=branchRates)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label	#
					},#
		   "clade" = {#
					transformPhy <- transformPhylo(phy=phy, model="clade", nodeIDs=nodeIDs, cladeRates=cladeRates, rateType=rateType)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "ou" = {#
		   			if (!is.ultrametric(phy)) {#
      			        cophenetic.dist <- cophenetic.phylo(phy)#
      			        vcv.matrix <- VCV.array(vcv.matrix)#
      			        phyMat <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs, cophenetic.dist=cophenetic.dist, vcv.matrix=vcv.matrix)#
      			        ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
      			        rownames(ydum) <- rownames(phyMat)#
      			        } else {#
      			        transformPhy <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs)#
						# phyMat <- VCV.array(transformPhy)#
						# attr(phyMat, "class") <- "matrix"#
						# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
						# rownames(ydum) <- rownames(phyMat)#
						ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
						rownames(ydum) <- phy$tip.label#
						}#
					},#
			"acdc" = {#
					transformPhy <- transformPhylo(phy=phy, model="ACDC", acdcRate=acdcRate, nodeIDs=nodeIDs, cladeRates=cladeRates)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
		   "psi" = {#
					transformPhy <- transformPhylo(phy = phy, model = "psi", psi = psi, lambda.sp = lambda.sp)#
					# phyMat <- VCV.array(transformPhy)#
					# attr(phyMat, "class") <- "matrix"#
					# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
					# rownames(ydum) <- rownames(phyMat)#
					ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
					},#
			"multipsi" = {#
       				transformPhy <- transformPhylo(phy = phy, model = "multipsi", psi = psi, lambda.sp = lambda.sp, branchLabels = branchLabels)#
       				# phyMat <- VCV.array(transformPhy)#
       				# attr(phyMat, "class") <- "matrix"#
        				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
        				# rownames(ydum) <- rownames(phyMat)#
        				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
    				},#
			"timeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="timeSlice", splitTime=splitTime, timeRates=timeRates)#
		   		# phyMat <- VCV.array(transformPhy)#
				# attr(phyMat, "class") <- "matrix"#
				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
				# rownames(ydum) <- rownames(phyMat)#
				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
				rownames(ydum) <- phy$tip.label#
		   		} ,#
		   	"modeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="modeSlice", mode.order=mode.order, splitTime=splitTime, cladeRates=cladeRates, rate.var=rate.var)#
		   		# phyMat <- VCV.array(transformPhy)#
				# attr(phyMat, "class") <- "matrix"#
				# ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
				# rownames(ydum) <- rownames(phyMat)#
				ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
				rownames(ydum) <- phy$tip.label#
		   		} ,#
#
			"mixedrate" = {#
        			x <- as.matrix(x)#
		        dat <- data.frame(x = x, y = rep(0, length(x[, 1])))#
		        rateData <- as.rateData(y = "y", x = "x", rateMatrix = NULL, phy = phy, data = dat)#
		        V <- transformRateMatrix(rateData, rate = rate)#
		        expect.sd <- sqrt(mean(V[upper.tri(V)]))#
		        if (is.null(group.means)) {#
		            # ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = (V))))#
		            # rownames(ydum) <- rownames(V)#
		            ydum <- sapply(1:n, function(ix) y.sim.function(transformPhy))#
					rownames(ydum) <- phy$tip.label#
		        } else {#
		            x.means <- unique(rateData$x)#
		            n.means <- length(x.means)#
		            samp.means <- rep(NA, length(rateData$x))#
		            ydum <- vector(mode = "list", length = length(group.means))#
		            for (i in 1:n.means) {#
		                samp.means[which(rateData$x == (i - 1))] <- rep(0 + (expect.sd * group.means[i]), length(which(rateData$x == (i - 1))))#
		            }#
		            ydum <- as.matrix(t(rmvnorm(n, mean = samp.means, sigma = (V))))#
		            rownames(ydum) <- rownames(V)#
		       		}#
		       	}#
		   )#
	return(ydum)#
}
transformPhylo.sim(anolis.tree, returnNodes=TRUE)
transformPhylo.sim(anolis.tree, returnNodes=TRUE, model="bm")
#' @title Phylogenetic tree transformations#
#' @description Simulates trait data on a tree using a specified model of evolution (see details).#
#' @param phy An object of class \code{phylo} (see \pkg{ape}).#
#' @param n Number of simulations#
#' @param x Vector, matrix or data.frame (with taxon names as names or rownames) of categories for each species. Only applicable if model="mixedRate" #
#' @param model The model of trait evolution (see details).#
#' @param returnNodes Logical. If TRUE, alongside the tip values all node values are returned corresponding to APE's edge.matrix for the tree.#
#' @param kappa Value of kappa transform.#
#' @param lambda Value of lambda transform.#
#' @param delta Value of delta transform.#
#' @param alpha Value of alpha (OU) transform.#
#' @param psi Value of psi transform.  Note that 'original nodes' from the full phylogeny can be included as an element on the phylogeny (e.g., phy$orig.node) as well as estimates of 'hidden' speciation (e.g., phy$hidden.speciation) if estimates of extinction (mu) are > 0.#
#' @param lambda.sp Estimate of speciation (lambda) for the psi models#
#' @param splitTime A split time (measured from the present, or most recent species) at which a shift in the rate occurs for the "timeSlice" model#
#' @param timeRates The rates (from ancient to recent) for the timeSlice model#
#' @param nodeIDs Integer - ancestral nodes of clades.#
#' @param rateType If model="clade", a vector specifying if rate shift occurs in a clade ("clade") or on the single branch leading to a clade ("branch").#
#' @param acdcRate Value of ACDC transform.#
#' @param trend value of the expectation mean change through time#
#' @param trend.anc.state the expected ancestal state for the trend model (default is 0)#
#' @param branchLabels Branches on which different psi parameters are estimated in the "multipsi" model.#
#' @param branchRates Numeric vector specifying relative rates for individual branches#
#' @param cladeRates Numeric vector specifying telative rates for clades.#
#' @param rate a vector of relative rate parameters. The length of the vector is equal to the number of rates being estimated. #
#' @param group.means a vector of the relative difference in means between rate categories, expressed as a scalar applied to the expected standard deviation (see Ricklefs 2006)#
#' @param mode.order The order of modes for the 'modeslice' model. Any combination of 'BM', 'OU', 'acdc', and 'kappa'#
#' @param cladeRates Numeric vector specifying telative rates for clades or logical to indicate scalar is included in the 'modeslice' model (the scalar is included in the mode.param argument with the 'modeslice' model).#
#' @param acdcScalar Logical.For nested EB rate model, simultaneously estimated a rate scalar alongside EB model. Default=FALSE. Only applicable to 'nested mode' and 'modeSlice' models.#
#' @param rate.var Allows rate variation in BM modes in the 'modeslice' model#
#' @return Returns a matrix of simulated dated with taxon names as rownames (number of columns=n).#
#' @references Ricklefs RE. 2006. Time, species, and the generation of trait variation in clades. Systematic Biology 55, 151-159.#
#' @references Ricklefs RE. 2006. Thomas GH, Meiri S, & Phillimore AB. 2009. Body size diversification in Anolis: novel environments and island effects. Evolution 63, 2017-2030#
#' @author Gavin Thomas, Mark Puttick#
#' @seealso \code{\link{transformPhylo.ML}}, \code{\link{transformPhylo.ll}}, \code{\link{transformPhylo}}, \code{\link{transformPhylo.MCMC}}#
#' @import mvtnorm#
#' @examples#
#' data(anolis.tree)#
#' data(anolis.data)#
#' #
#' # Simulate 10 sets of data with kappa=0.1 using the anolis tree#
#' sim.dat1 <- transformPhylo.sim(phy=anolis.tree, n=10, model="kappa", kappa=0.1)#
#' #
#' # Simulate 10 sets of data where rates and means differ between to the categories defined by "x"#
#' x <- anolis.data$geo_ecomorph#
#' names(x) <-  rownames(anolis.data)#
#' sim.dat2 <- transformPhylo.sim(phy=anolis.tree, n=10, x=x, model="mixedRate", rate=c(1,1,2,4),#
#' group.means=c(0,5,0,0))#
#' @export#
#
transformPhylo.sim <- function(phy, n=1, x=NULL, model=NULL, returnNodes=FALSE, kappa=NULL, lambda=NULL, delta=NULL, alpha=NULL, psi=NULL, acdcRate=NULL, lambda.sp = NULL, trend=NULL, trend.anc.state=0, nodeIDs=NULL, rateType=NULL, cladeRates=NULL, branchRates=NULL, rate=NULL, group.means=NULL, splitTime=NULL, timeRates=NULL, branchLabels = NULL) {#
	  model <- tolower(model)#
	all.models <- c("bm", "trend", "kappa", "lambda", "delta", "free", "clade", "ou", "acdc", "psi", "multipsi", "timeslice", "mixedrate")#
	if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
	y.sim.function <- function(phy, return.node=FALSE) {	#
		lengths <- phy$edge.length#
		empty.mat <- matrix(NA, nrow=nrow(phy$edge), ncol=2)#
		start.nodes <- which(phy$edge[,1] == Ntip(phy) + 1)#
		empty.mat[start.nodes,1] <- rnorm(1)#
		while(length(start.nodes) != 0) {#
			next.node <- phy$edge[start.nodes,2]#
			var.to.add <- rnorm(length(start.nodes), sd=sqrt(lengths[start.nodes]))#
			empty.mat[start.nodes,2] <- empty.mat[start.nodes,1] + var.to.add#
			start.nodes.int <- c()#
			for(xx in 1:length(next.node)) {#
				n.n <- which(phy$edge[,1] == next.node[xx])#
				empty.mat[n.n,1] <- empty.mat[start.nodes[xx], 2]#
				}#
			start.nodes <- intersect(which(complete.cases(empty.mat[, 1])), which(!complete.cases(empty.mat[, 2])))#
			}	#
		tips <- which(phy$edge[, 2] <= Ntip(phy))#
		y.out <- list()#
		y.out$y <- matrix(empty.mat[tips, 2], dimnames=list(phy$tip.label))#
		if(return.node) y.out$all.nodes <- empty.mat#
		return(y.out)#
		}#
#
	switch(model,		  #
		   "bm" = {#
					transformPhy <- phy#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
			 "trend" = {#
					transformPhy <- phy#
					phyMat <- VCV.array(transformPhy)#
					attr(phyMat, "class") <- "matrix"#
					tip.distance <- diag(vcv(transformPhy))#
					trend.mean <- trend.anc.state + (tip.distance * trend)#
					ydum <- as.matrix(t(mvtnorm::rmvnorm(n, mean=trend.mean, sigma = phyMat)))#
					rownames(ydum) <- rownames(phyMat)#
					if(returnNodes) warning("returnNodes not applicable to trend model, sorry")#
					},#
		   "kappa" = {#
					transformPhy <- transformPhylo(phy=phy, model="kappa", kappa=kappa, nodeIDs=nodeIDs)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "lambda" = {#
					transformPhy <- transformPhylo(phy=phy, model="lambda", lambda=lambda)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "delta" = {#
					transformPhy <- transformPhylo(phy=phy, model="delta", delta=delta, nodeIDs=nodeIDs)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "free" = {#
					transformPhy <- transformPhylo(phy=phy, model="free", branchRates=branchRates)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "clade" = {#
					transformPhy <- transformPhylo(phy=phy, model="clade", nodeIDs=nodeIDs, cladeRates=cladeRates, rateType=rateType)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "ou" = {#
		   			if (!is.ultrametric(phy)) {#
      			        cophenetic.dist <- cophenetic.phylo(phy)#
      			        vcv.matrix <- VCV.array(vcv.matrix)#
      			        phyMat <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs, cophenetic.dist=cophenetic.dist, vcv.matrix=vcv.matrix)#
      			        ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
      			        rownames(ydum) <- rownames(phyMat)#
      			        if(returnNodes) warning("returnNodes not applicable to OU model with non-ultrametric trees, sorry")#
      			        } else {#
      			        transformPhy <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs)#
						ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
						ydum <- sapply(ydum.all, function(re) re[[1]])#
						rownames(ydum) <- phy$tip.label#
						if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
						}#
					},#
			"acdc" = {#
					transformPhy <- transformPhylo(phy=phy, model="ACDC", acdcRate=acdcRate, nodeIDs=nodeIDs, cladeRates=cladeRates)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "psi" = {#
					transformPhy <- transformPhylo(phy = phy, model = "psi", psi = psi, lambda.sp = lambda.sp)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
			"multipsi" = {#
       				transformPhy <- transformPhylo(phy = phy, model = "multipsi", psi = psi, lambda.sp = lambda.sp, branchLabels = branchLabels)#
       				ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
    				},#
			"timeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="timeSlice", splitTime=splitTime, timeRates=timeRates)#
		   		ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
				ydum <- sapply(ydum.all, function(re) re[[1]])#
				rownames(ydum) <- phy$tip.label#
				if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
		   		} ,#
		   	"modeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="modeSlice", mode.order=mode.order, splitTime=splitTime, cladeRates=cladeRates, rate.var=rate.var)#
		   		ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
				ydum <- sapply(ydum.all, function(re) re[[1]])#
				rownames(ydum) <- phy$tip.label#
				if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
		   		} ,#
#
			"mixedrate" = {#
        			x <- as.matrix(x)#
		        dat <- data.frame(x = x, y = rep(0, length(x[, 1])))#
		        rateData <- as.rateData(y = "y", x = "x", rateMatrix = NULL, phy = phy, data = dat)#
		        V <- transformRateMatrix(rateData, rate = rate)#
		        expect.sd <- sqrt(mean(V[upper.tri(V)]))#
		        if (is.null(group.means)) {#
		            ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
		        } else {#
		            x.means <- unique(rateData$x)#
		            n.means <- length(x.means)#
		            samp.means <- rep(NA, length(rateData$x))#
		            ydum <- vector(mode = "list", length = length(group.means))#
		            for (i in 1:n.means) {#
		                samp.means[which(rateData$x == (i - 1))] <- rep(0 + (expect.sd * group.means[i]), length(which(rateData$x == (i - 1))))#
		            }#
		            ydum <- as.matrix(t(rmvnorm(n, mean = samp.means, sigma = (V))))#
		            rownames(ydum) <- rownames(V)#
		       		if(returnNodes) warning("returnNodes not applicable to mixedrate model with non-ultrametric trees unique nodes, sorry")#
		       	}#
		   )#
	return(ydum)#
}
transformPhylo.sim <- function(phy, n=1, x=NULL, model=NULL, returnNodes=FALSE, kappa=NULL, lambda=NULL, delta=NULL, alpha=NULL, psi=NULL, acdcRate=NULL, lambda.sp = NULL, trend=NULL, trend.anc.state=0, nodeIDs=NULL, rateType=NULL, cladeRates=NULL, branchRates=NULL, rate=NULL, group.means=NULL, splitTime=NULL, timeRates=NULL, branchLabels = NULL) {#
	  model <- tolower(model)#
	all.models <- c("bm", "trend", "kappa", "lambda", "delta", "free", "clade", "ou", "acdc", "psi", "multipsi", "timeslice", "mixedrate")#
	if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
	y.sim.function <- function(phy, return.node=FALSE) {	#
		lengths <- phy$edge.length#
		empty.mat <- matrix(NA, nrow=nrow(phy$edge), ncol=2)#
		start.nodes <- which(phy$edge[,1] == Ntip(phy) + 1)#
		empty.mat[start.nodes,1] <- rnorm(1)#
		while(length(start.nodes) != 0) {#
			next.node <- phy$edge[start.nodes,2]#
			var.to.add <- rnorm(length(start.nodes), sd=sqrt(lengths[start.nodes]))#
			empty.mat[start.nodes,2] <- empty.mat[start.nodes,1] + var.to.add#
			start.nodes.int <- c()#
			for(xx in 1:length(next.node)) {#
				n.n <- which(phy$edge[,1] == next.node[xx])#
				empty.mat[n.n,1] <- empty.mat[start.nodes[xx], 2]#
				}#
			start.nodes <- intersect(which(complete.cases(empty.mat[, 1])), which(!complete.cases(empty.mat[, 2])))#
			}	#
		tips <- which(phy$edge[, 2] <= Ntip(phy))#
		y.out <- list()#
		y.out$y <- matrix(empty.mat[tips, 2], dimnames=list(phy$tip.label))#
		if(return.node) y.out$all.nodes <- empty.mat#
		return(y.out)#
		}
switch(model,		  #
		   "bm" = {#
					transformPhy <- phy#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
			 "trend" = {#
					transformPhy <- phy#
					phyMat <- VCV.array(transformPhy)#
					attr(phyMat, "class") <- "matrix"#
					tip.distance <- diag(vcv(transformPhy))#
					trend.mean <- trend.anc.state + (tip.distance * trend)#
					ydum <- as.matrix(t(mvtnorm::rmvnorm(n, mean=trend.mean, sigma = phyMat)))#
					rownames(ydum) <- rownames(phyMat)#
					if(returnNodes) warning("returnNodes not applicable to trend model, sorry")#
					},
"kappa" = {#
					transformPhy <- transformPhylo(phy=phy, model="kappa", kappa=kappa, nodeIDs=nodeIDs)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "lambda" = {#
					transformPhy <- transformPhylo(phy=phy, model="lambda", lambda=lambda)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},
"delta" = {#
					transformPhy <- transformPhylo(phy=phy, model="delta", delta=delta, nodeIDs=nodeIDs)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "free" = {#
					transformPhy <- transformPhylo(phy=phy, model="free", branchRates=branchRates)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},
"clade" = {#
					transformPhy <- transformPhylo(phy=phy, model="clade", nodeIDs=nodeIDs, cladeRates=cladeRates, rateType=rateType)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "ou" = {#
		   			if (!is.ultrametric(phy)) {#
      			        cophenetic.dist <- cophenetic.phylo(phy)#
      			        vcv.matrix <- VCV.array(vcv.matrix)#
      			        phyMat <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs, cophenetic.dist=cophenetic.dist, vcv.matrix=vcv.matrix)#
      			        ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
      			        rownames(ydum) <- rownames(phyMat)#
      			        if(returnNodes) warning("returnNodes not applicable to OU model with non-ultrametric trees, sorry")#
      			        } else {#
      			        transformPhy <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs)#
						ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
						ydum <- sapply(ydum.all, function(re) re[[1]])#
						rownames(ydum) <- phy$tip.label#
						if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
						}#
					},
"acdc" = {#
					transformPhy <- transformPhylo(phy=phy, model="ACDC", acdcRate=acdcRate, nodeIDs=nodeIDs, cladeRates=cladeRates)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},
"psi" = {#
					transformPhy <- transformPhylo(phy = phy, model = "psi", psi = psi, lambda.sp = lambda.sp)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},
"multipsi" = {#
       				transformPhy <- transformPhylo(phy = phy, model = "multipsi", psi = psi, lambda.sp = lambda.sp, branchLabels = branchLabels)#
       				ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
    				},
"timeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="timeSlice", splitTime=splitTime, timeRates=timeRates)#
		   		ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
				ydum <- sapply(ydum.all, function(re) re[[1]])#
				rownames(ydum) <- phy$tip.label#
				if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
		   		} ,
"modeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="modeSlice", mode.order=mode.order, splitTime=splitTime, cladeRates=cladeRates, rate.var=rate.var)#
		   		ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
				ydum <- sapply(ydum.all, function(re) re[[1]])#
				rownames(ydum) <- phy$tip.label#
				if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
		   		} ,
#' @title Phylogenetic tree transformations#
#' @description Simulates trait data on a tree using a specified model of evolution (see details).#
#' @param phy An object of class \code{phylo} (see \pkg{ape}).#
#' @param n Number of simulations#
#' @param x Vector, matrix or data.frame (with taxon names as names or rownames) of categories for each species. Only applicable if model="mixedRate" #
#' @param model The model of trait evolution (see details).#
#' @param returnNodes Logical. If TRUE, alongside the tip values all node values are returned corresponding to APE's edge.matrix for the tree.#
#' @param kappa Value of kappa transform.#
#' @param lambda Value of lambda transform.#
#' @param delta Value of delta transform.#
#' @param alpha Value of alpha (OU) transform.#
#' @param psi Value of psi transform.  Note that 'original nodes' from the full phylogeny can be included as an element on the phylogeny (e.g., phy$orig.node) as well as estimates of 'hidden' speciation (e.g., phy$hidden.speciation) if estimates of extinction (mu) are > 0.#
#' @param lambda.sp Estimate of speciation (lambda) for the psi models#
#' @param splitTime A split time (measured from the present, or most recent species) at which a shift in the rate occurs for the "timeSlice" model#
#' @param timeRates The rates (from ancient to recent) for the timeSlice model#
#' @param nodeIDs Integer - ancestral nodes of clades.#
#' @param rateType If model="clade", a vector specifying if rate shift occurs in a clade ("clade") or on the single branch leading to a clade ("branch").#
#' @param acdcRate Value of ACDC transform.#
#' @param trend value of the expectation mean change through time#
#' @param trend.anc.state the expected ancestal state for the trend model (default is 0)#
#' @param branchLabels Branches on which different psi parameters are estimated in the "multipsi" model.#
#' @param branchRates Numeric vector specifying relative rates for individual branches#
#' @param cladeRates Numeric vector specifying telative rates for clades.#
#' @param rate a vector of relative rate parameters. The length of the vector is equal to the number of rates being estimated. #
#' @param group.means a vector of the relative difference in means between rate categories, expressed as a scalar applied to the expected standard deviation (see Ricklefs 2006)#
#' @param mode.order The order of modes for the 'modeslice' model. Any combination of 'BM', 'OU', 'acdc', and 'kappa'#
#' @param cladeRates Numeric vector specifying telative rates for clades or logical to indicate scalar is included in the 'modeslice' model (the scalar is included in the mode.param argument with the 'modeslice' model).#
#' @param acdcScalar Logical.For nested EB rate model, simultaneously estimated a rate scalar alongside EB model. Default=FALSE. Only applicable to 'nested mode' and 'modeSlice' models.#
#' @param rate.var Allows rate variation in BM modes in the 'modeslice' model#
#' @return Returns a matrix of simulated dated with taxon names as rownames (number of columns=n).#
#' @references Ricklefs RE. 2006. Time, species, and the generation of trait variation in clades. Systematic Biology 55, 151-159.#
#' @references Ricklefs RE. 2006. Thomas GH, Meiri S, & Phillimore AB. 2009. Body size diversification in Anolis: novel environments and island effects. Evolution 63, 2017-2030#
#' @author Gavin Thomas, Mark Puttick#
#' @seealso \code{\link{transformPhylo.ML}}, \code{\link{transformPhylo.ll}}, \code{\link{transformPhylo}}, \code{\link{transformPhylo.MCMC}}#
#' @import mvtnorm#
#' @examples#
#' data(anolis.tree)#
#' data(anolis.data)#
#' #
#' # Simulate 10 sets of data with kappa=0.1 using the anolis tree#
#' sim.dat1 <- transformPhylo.sim(phy=anolis.tree, n=10, model="kappa", kappa=0.1)#
#' #
#' # Simulate 10 sets of data where rates and means differ between to the categories defined by "x"#
#' x <- anolis.data$geo_ecomorph#
#' names(x) <-  rownames(anolis.data)#
#' sim.dat2 <- transformPhylo.sim(phy=anolis.tree, n=10, x=x, model="mixedRate", rate=c(1,1,2,4),#
#' group.means=c(0,5,0,0))#
#' @export#
#
transformPhylo.sim <- function(phy, n=1, x=NULL, model=NULL, returnNodes=FALSE, kappa=NULL, lambda=NULL, delta=NULL, alpha=NULL, psi=NULL, acdcRate=NULL, lambda.sp = NULL, trend=NULL, trend.anc.state=0, nodeIDs=NULL, rateType=NULL, cladeRates=NULL, branchRates=NULL, rate=NULL, group.means=NULL, splitTime=NULL, timeRates=NULL, branchLabels = NULL) {#
	  model <- tolower(model)#
	all.models <- c("bm", "trend", "kappa", "lambda", "delta", "free", "clade", "ou", "acdc", "psi", "multipsi", "timeslice", "mixedrate")#
	if (any(is.na((match(model, all.models))))) stop(paste(model, "not recognised - please provide one of", paste0(all.models, collapse = ", ")))#
	y.sim.function <- function(phy, return.node=FALSE) {	#
		lengths <- phy$edge.length#
		empty.mat <- matrix(NA, nrow=nrow(phy$edge), ncol=2)#
		start.nodes <- which(phy$edge[,1] == Ntip(phy) + 1)#
		empty.mat[start.nodes,1] <- rnorm(1)#
		while(length(start.nodes) != 0) {#
			next.node <- phy$edge[start.nodes,2]#
			var.to.add <- rnorm(length(start.nodes), sd=sqrt(lengths[start.nodes]))#
			empty.mat[start.nodes,2] <- empty.mat[start.nodes,1] + var.to.add#
			start.nodes.int <- c()#
			for(xx in 1:length(next.node)) {#
				n.n <- which(phy$edge[,1] == next.node[xx])#
				empty.mat[n.n,1] <- empty.mat[start.nodes[xx], 2]#
				}#
			start.nodes <- intersect(which(complete.cases(empty.mat[, 1])), which(!complete.cases(empty.mat[, 2])))#
			}	#
		tips <- which(phy$edge[, 2] <= Ntip(phy))#
		y.out <- list()#
		y.out$y <- matrix(empty.mat[tips, 2], dimnames=list(phy$tip.label))#
		if(return.node) y.out$all.nodes <- empty.mat#
		return(y.out)#
		}#
#
	switch(model,		  #
		   "bm" = {#
					transformPhy <- phy#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
			 "trend" = {#
					transformPhy <- phy#
					phyMat <- VCV.array(transformPhy)#
					attr(phyMat, "class") <- "matrix"#
					tip.distance <- diag(vcv(transformPhy))#
					trend.mean <- trend.anc.state + (tip.distance * trend)#
					ydum <- as.matrix(t(mvtnorm::rmvnorm(n, mean=trend.mean, sigma = phyMat)))#
					rownames(ydum) <- rownames(phyMat)#
					if(returnNodes) warning("returnNodes not applicable to trend model, sorry")#
					},#
		   "kappa" = {#
					transformPhy <- transformPhylo(phy=phy, model="kappa", kappa=kappa, nodeIDs=nodeIDs)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "lambda" = {#
					transformPhy <- transformPhylo(phy=phy, model="lambda", lambda=lambda)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "delta" = {#
					transformPhy <- transformPhylo(phy=phy, model="delta", delta=delta, nodeIDs=nodeIDs)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "free" = {#
					transformPhy <- transformPhylo(phy=phy, model="free", branchRates=branchRates)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "clade" = {#
					transformPhy <- transformPhylo(phy=phy, model="clade", nodeIDs=nodeIDs, cladeRates=cladeRates, rateType=rateType)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "ou" = {#
		   			if (!is.ultrametric(phy)) {#
      			        cophenetic.dist <- cophenetic.phylo(phy)#
      			        vcv.matrix <- VCV.array(vcv.matrix)#
      			        phyMat <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs, cophenetic.dist=cophenetic.dist, vcv.matrix=vcv.matrix)#
      			        ydum <- as.matrix(t(mvtnorm::rmvnorm(n, sigma = phyMat)))#
      			        rownames(ydum) <- rownames(phyMat)#
      			        if(returnNodes) warning("returnNodes not applicable to OU model with non-ultrametric trees, sorry")#
      			        } else {#
      			        transformPhy <- transformPhylo(phy=phy, model="OU", alpha=alpha, nodeIDs=nodeIDs)#
						ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
						ydum <- sapply(ydum.all, function(re) re[[1]])#
						rownames(ydum) <- phy$tip.label#
						if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
						}#
					},#
			"acdc" = {#
					transformPhy <- transformPhylo(phy=phy, model="ACDC", acdcRate=acdcRate, nodeIDs=nodeIDs, cladeRates=cladeRates)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
		   "psi" = {#
					transformPhy <- transformPhylo(phy = phy, model = "psi", psi = psi, lambda.sp = lambda.sp)#
					ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
					},#
			"multipsi" = {#
       				transformPhy <- transformPhylo(phy = phy, model = "multipsi", psi = psi, lambda.sp = lambda.sp, branchLabels = branchLabels)#
       				ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
    				},#
			"timeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="timeSlice", splitTime=splitTime, timeRates=timeRates)#
		   		ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
				ydum <- sapply(ydum.all, function(re) re[[1]])#
				rownames(ydum) <- phy$tip.label#
				if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
		   		} ,#
		   	"modeslice" = {#
				phy2 <- phy	   #
		   		transformPhy <- transformPhylo(phy=phy, model="modeSlice", mode.order=mode.order, splitTime=splitTime, cladeRates=cladeRates, rate.var=rate.var)#
		   		ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
				ydum <- sapply(ydum.all, function(re) re[[1]])#
				rownames(ydum) <- phy$tip.label#
				if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
		   		} ,#
#
			"mixedrate" = {#
        			x <- as.matrix(x)#
		        dat <- data.frame(x = x, y = rep(0, length(x[, 1])))#
		        rateData <- as.rateData(y = "y", x = "x", rateMatrix = NULL, phy = phy, data = dat)#
		        V <- transformRateMatrix(rateData, rate = rate)#
		        expect.sd <- sqrt(mean(V[upper.tri(V)]))#
		        if (is.null(group.means)) {#
		            ydum.all <- lapply(1:n, function(ix) y.sim.function(transformPhy, return.node=returnNodes))#
					ydum <- sapply(ydum.all, function(re) re[[1]])#
					rownames(ydum) <- phy$tip.label#
					if(returnNodes) ydum <- list(trait.values=ydum, all.nodes=lapply(ydum.all, function(re) re[[2]]))#
		        } else {#
		            x.means <- unique(rateData$x)#
		            n.means <- length(x.means)#
		            samp.means <- rep(NA, length(rateData$x))#
		            ydum <- vector(mode = "list", length = length(group.means))#
		            for (i in 1:n.means) {#
		                samp.means[which(rateData$x == (i - 1))] <- rep(0 + (expect.sd * group.means[i]), length(which(rateData$x == (i - 1))))#
		            }#
		            ydum <- as.matrix(t(rmvnorm(n, mean = samp.means, sigma = (V))))#
		            rownames(ydum) <- rownames(V)#
		       		if(returnNodes) warning("returnNodes not applicable to mixedrate model with non-ultrametric trees unique nodes, sorry")#
		       		}#
		       	}#
		   )#
	return(ydum)#
}

uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))
ou.fun(lowerBound[1])
if (ou.fun(lowerBound[1]) < 0) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }
if (ou.fun(upperBound)[1] < 0) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
lambdaPhy
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = FALSE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[1 + n.par]#
      }
ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(-ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
f <- function (x) x ^ 2 - 4
curve(f, from = -5, to = 5)
uniroot(f, lower = -5, upper = 0)
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
try(uniroot(f, lower = -5, upper = 0)$root, silent=TRUE)
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = FALSE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
ancestral.state <- brVar <- NA#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[1 + n.par]#
      }#
#
      if (modelCIs == TRUE) {#
        ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (!is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (!is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
!is.numeric(lower.attempt)
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = FALSE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[1 + n.par]#
      }#
#
      if (modelCIs == TRUE) {#
        ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)
curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)
abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
out <- list()#
      out$MaximumLikelihood <- vo$value[1]
if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }
ouPhy <- transformPhylo(y = y, phy = lambdaPhy, model = "OU", alpha = vo$par[1], meserr = meserr)
ouPhy
likTraitPhylo(y = y, phy = ouPhy, covPIC = covPIC)
ouPhy
vo$value
vo
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[1 + n.par]#
      }#
#
      if (modelCIs == TRUE) {#
        ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }#
#
      if (profilePlot) {#
        par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }#
      }#
#
      out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }#
#
      ouPhy <- transformPhylo(y = y, phy = lambdaPhy, model = "OU", alpha = vo$par[1], meserr = meserr)#
      if(is.ultrametric(phy)) {#
      	out$brownianVariance <- likTraitPhylo(y = y, phy = ouPhy, covPIC = covPIC)$brownianVariance#
      	out$root.state <- apply(y, 2, function(col.y) as.numeric(as.numeric(ace(col.y, phy = ouPhy, method = "pic")[[1]][1])))#
      } else {#
      	out$brownianVariance <- brVar#
      	out$root.state <- ancestral.state#
      }#
      names(out) <- c("MaximumLikelihood", "Alpha", "brownianVariance", "root.state")#
      param <- 3#
      if (lambdaEst) {#
        out$lambda <- vo$par[2]#
        param <- 4#
      }#
      out$AIC <- aic.fun(out$MaximumLikelihood, param)#
      out$AICc <- aicc.fun(out$MaximumLikelihood, param, Ntip(phy))#
      if (returnPhy) out$ouPhy <- ouPhy
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = FALSE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[1 + n.par]#
      }#
#
      if (modelCIs == TRUE) {#
        ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }#
#
      if (profilePlot) {#
        par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }#
      }#
#
      out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }#
#
      ouPhy <- transformPhylo(y = y, phy = lambdaPhy, model = "OU", alpha = vo$par[1], meserr = meserr)#
      if(is.ultrametric(phy)) {#
      	out$brownianVariance <- likTraitPhylo(y = y, phy = ouPhy, covPIC = covPIC)$brownianVariance#
      	out$root.state <- apply(y, 2, function(col.y) as.numeric(as.numeric(ace(col.y, phy = ouPhy, method = "pic")[[1]][1])))#
      } else {#
      	out$brownianVariance <- brVar#
      	out$root.state <- ancestral.state#
      }#
      names(out) <- c("MaximumLikelihood", "Alpha", "brownianVariance", "root.state")#
      param <- 3#
      if (lambdaEst) {#
        out$lambda <- vo$par[2]#
        param <- 4#
      }#
      out$AIC <- aic.fun(out$MaximumLikelihood, param)#
      out$AICc <- aicc.fun(out$MaximumLikelihood, param, Ntip(phy))#
      if (returnPhy) out$ouPhy <- ouPhy
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)
vo
if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
ancestral.state <- brVar <- NA#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[1 + n.par]#
      }
ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }
out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }
ouPhy <- transformPhylo(y = y, phy = lambdaPhy, model = "OU", alpha = vo$par[1], meserr = meserr)#
      if(is.ultrametric(phy)) {#
      	out$brownianVariance <- likTraitPhylo(y = y, phy = ouPhy, covPIC = covPIC)$brownianVariance#
      	out$root.state <- apply(y, 2, function(col.y) as.numeric(as.numeric(ace(col.y, phy = ouPhy, method = "pic")[[1]][1])))#
      } else {#
      	out$brownianVariance <- brVar#
      	out$root.state <- ancestral.state#
      }#
      names(out) <- c("MaximumLikelihood", "Alpha", "brownianVariance", "root.state")#
      param <- 3#
      if (lambdaEst) {#
        out$lambda <- vo$par[2]#
        param <- 4#
      }
out$AIC <- aic.fun(out$MaximumLikelihood, param)
out$AICc <- aicc.fun(out$MaximumLikelihood, param, Ntip(phy))
out
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[2 + n.par]#
      }
u.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }
ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)
upper.attempt
UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root
UCI
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }
LCI <- lowerBound[1]
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }
out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }#
#
      ouPhy <- transformPhylo(y = y, phy = lambdaPhy, model = "OU", alpha = vo$par[1], meserr = meserr)#
      if(is.ultrametric(phy)) {#
      	out$brownianVariance <- likTraitPhylo(y = y, phy = ouPhy, covPIC = covPIC)$brownianVariance#
      	out$root.state <- apply(y, 2, function(col.y) as.numeric(as.numeric(ace(col.y, phy = ouPhy, method = "pic")[[1]][1])))#
      } else {#
      	out$brownianVariance <- brVar#
      	out$root.state <- ancestral.state#
      }#
      names(out) <- c("MaximumLikelihood", "Alpha", "brownianVariance", "root.state")
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rcoal(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)
vo
alpha
n.par
param=alpha
if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
ransformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])
transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])
lowerBound
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rcoal(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }
vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)
vo
lowerBound
upperBound
if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
ancestral.state <- brVar <- NA#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[2 + n.par]#
      }
ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)
upper.attempt
if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }
vcv.matrix
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rcoal(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      vcv.matrix <- NULL#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[2 + n.par]#
      	vcv.matrix <- vcv(phy)#
      }
vo
ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)
upper.attempt
if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }
out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }
ouPhy <- transformPhylo(y = y, phy = lambdaPhy, model = "OU", alpha = vo$par[1], meserr = meserr)#
      if(is.ultrametric(phy)) {#
      	out$brownianVariance <- likTraitPhylo(y = y, phy = ouPhy, covPIC = covPIC)$brownianVariance#
      	out$root.state <- apply(y, 2, function(col.y) as.numeric(as.numeric(ace(col.y, phy = ouPhy, method = "pic")[[1]][1])))#
      } else {#
      	out$brownianVariance <- brVar#
      	out$root.state <- ancestral.state#
      }
names(out) <- c("MaximumLikelihood", "Alpha", "brownianVariance", "root.state")
param <- 3#
      if (lambdaEst) {#
        out$lambda <- vo$par[2]#
        param <- 4#
      }#
      out$AIC <- aic.fun(out$MaximumLikelihood, param)#
      out$AICc <- aicc.fun(out$MaximumLikelihood, param, Ntip(phy))
out
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rcoal(80)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
vo
ancestral.state <- brVar <- NA#
      vcv.matrix <- NULL#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[2 + n.par]#
      	vcv.matrix <- vcv(phy)#
      }
if (modelCIs == TRUE) {#
        ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }
if (profilePlot) {#
        par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }#
      }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }
out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }#
#
      ouPhy <- transformPhylo(y = y, phy = lambdaPhy, model = "OU", alpha = vo$par[1], meserr = meserr)#
      if(is.ultrametric(phy)) {#
      	out$brownianVariance <- likTraitPhylo(y = y, phy = ouPhy, covPIC = covPIC)$brownianVariance#
      	out$root.state <- apply(y, 2, function(col.y) as.numeric(as.numeric(ace(col.y, phy = ouPhy, method = "pic")[[1]][1])))#
      } else {#
      	out$brownianVariance <- brVar#
      	out$root.state <- ancestral.state#
      }#
      names(out) <- c("MaximumLikelihood", "Alpha", "brownianVariance", "root.state")#
      param <- 3#
      if (lambdaEst) {#
        out$lambda <- vo$par[2]#
        param <- 4#
      }#
      out$AIC <- aic.fun(out$MaximumLikelihood, param)#
      out$AICc <- aicc.fun(out$MaximumLikelihood, param, Ntip(phy))
out
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(80)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(80)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        if(!is.ultrametric(phy)) vcv.matrix <- lambdaPhy#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(80)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        if(!is.ultrametric(phy)) vcv.matrix <- vcv(lambdaPhy)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
ancestral.state <- brVar <- NA#
      vcv.matrix <- NULL#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[2 + n.par]#
      	vcv.matrix <- vcv( lambdaPhy)#
      }
ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }
lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)
lower.attempt
if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }
upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }
LCI
UCI
rm(list=ls(all=T))#
#
model = NULL;modelCIs = TRUE;nodeIDs = NULL;rateType = NULL;minCladeSize = 1;nSplits = 2;splitTime = NULL;boundaryAge = 10;testAge = 1;restrictNode = NULL;lambdaEst = TRUE;acdcScalar = FALSE;branchLabels = NULL;hiddenSpeciation = FALSE;full.phy = NULL;useMean = FALSE;profilePlot = FALSE;lowerBound = NULL;upperBound = NULL;covPIC = TRUE;n.cores = 1;tol = NULL;meserr = NULL;controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5);returnPhy = FALSE;print.warnings = FALSE#
#
  bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
  rownames(bounds) <- c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcrate")#
#
 lower.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing lowerBound")#
  upper.function.warning <- function() if (print.warnings) warning("Confidence limits fall outside parameter bounds - consider changing upperBound")#
  aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
  aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))#
set.seed(93011342)#
phy <- phy.start <- rtree(8)#
y <- transformPhylo.sim(phy, 1, model="bm")#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.ll.R', chdir = TRUE)#
 source('~/Documents/GitHub/motmot.2.0/R/transformPhylo.R', chdir = TRUE)
alpha <- 0.5#
      if (is.null(nodeIDs)) nodeIDs <- Ntip(phy) + 1 else nodeIDs <- nodeIDs#
      if (lambdaEst) {#
        alpha[2] <- 1#
      }#
      if (is.null(lowerBound)) {#
        lowerBound <- bounds["alpha", 1]#
        if (lambdaEst) lowerBound[2] <- bounds["lambda", 1]#
      }#
      if (is.null(upperBound)) {#
        upperBound <- bounds["alpha", 2]#
        if (lambdaEst) upperBound[2] <- bounds["lambda", 2]#
      }#
      n.par <- length(lowerBound)#
      if (!is.ultrametric(phy)) {#
      	if(ncol(y) > 1) stop("non-ultrametric phy and OU model only applicable for single traits, sorry")#
      	print("non-ultrametric phy and OU model - using variance-covariance matrix, not tree-transformation")#
        cophenetic.dist <- cophenetic.phylo(phy)#
        vcv.matrix <- vcv(phy)#
       	alpha[n.par + c(1, 2)] <- 1#
       	lowerBound[n.par + (1:2)] <- c(1e-8, NA)#
       	upperBound[n.par + (1:2)] <- c(NA, NA)#
      }#
#
      var.funOU <- function(param) {#
        if (length(param) != 2) {#
          lambda <- 1#
        } else {#
          lambda <- param[2]#
        }#
        alpha.int <- param[1]#
        lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
        if(!is.ultrametric(phy)) vcv.matrix <- vcv(lambdaPhy)#
        return(transformPhylo.ll(y = y, phy = lambdaPhy, alpha = alpha.int, nodeIDs = nodeIDs, model = "OU", meserr = meserr, covPIC = covPIC, cophenetic.dist = cophenetic.dist, vcv.matrix = vcv.matrix,  ancestral.state=param[1 + n.par], brVar=param[2 + n.par])[[2]])#
      }#
#
      vo <- optim(alpha, var.funOU, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)#
      if (lambdaEst) {#
        lambda <- vo$par[2]#
      } else {#
        lambda <- 1#
      }#
      lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
      ancestral.state <- brVar <- NA#
      vcv.matrix <- NULL#
      if (!is.ultrametric(phy)) {#
      	ancestral.state <- vo$par[1 + n.par]#
      	brVar <- vo$par[2 + n.par]#
      	vcv.matrix <- vcv( lambdaPhy)#
      }#
#
      if (modelCIs == TRUE) {#
        ou.fun <- function(param, chiSq = TRUE) {#
          ll <- transformPhylo.ll(y, lambdaPhy, model = "OU", alpha = param, nodeIDs = nodeIDs, meserr = meserr, covPIC = covPIC, vcv.matrix = vcv.matrix,  ancestral.state=ancestral.state, brVar=brVar)$logLikelihood#
          if (chiSq) {#
            return(ll - vo$value + 1.92)#
          } else {#
            return(ll)#
          }#
        }#
        lower.attempt <- try(uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root, silent=TRUE)#
        if (is.numeric(lower.attempt)) {#
          LCI <- uniroot(ou.fun, interval = c(lowerBound[1], vo$par[1]))$root#
        } else {#
          LCI <- lowerBound[1]#
          lower.function.warning()#
        }#
        upper.attempt <- try(uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root, silent=TRUE)#
        if (is.numeric(upper.attempt)) {#
          UCI <- uniroot(ou.fun, interval = c(vo$par[1], upperBound[1]))$root#
        } else {#
          UCI <- upperBound[1]#
          upper.function.warning()#
        }#
      }#
#
      if (profilePlot) {#
        par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }#
      }#
#
      out <- list()#
      out$MaximumLikelihood <- vo$value[1]#
      if (modelCIs) {#
        out$Alpha <- matrix(c(vo$par[1], LCI, UCI), 1, 3, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha", "LowerCI", "UpperCI")#
      } else {#
        out$Alpha <- matrix(vo$par[1], 1, 1, byrow = TRUE)#
        colnames(out$Alpha) <- c("MLAlpha")#
      }
par(mar = c(5, 5, 5, 5), oma = c(0, 0, 0, 0))#
        ouCurve <- Vectorize(ou.fun)#
        curve(ouCurve(x, FALSE), from = lowerBound[1], to = upperBound[1], xlab = expression(alpha), ylab = "log-likelihood", las = 1, main = "profile plot", lwd = 2)#
        if (modelCIs) {#
          abline(v = c(LCI, vo$par[1], UCI), lty = c(3, 2, 3), lwd = 2, col = "#00000090")#
        }
is
is.matrix
is.data.frame
VCV.array
library(caper)
VCV.array
library(methods)
is
library(motmot.2.0)
sortTraitData
sortTraitData(anolis.tree, anolis.data, data.name = Male_SVL, log.trait = TRUE, pass.ultrametric = TRUE)
sortedData <- sortTraitData(anolis.tree, anolis.data, data.name = "Male_SVL", log.trait = TRUE, pass.ultrametric = TRUE)
rm(list=ls(all=T))
data(anolis.data)
data(anolis.tree)
sortedData <- sortTraitData(anolis.tree, anolis.data, data.name = "Male_SVL", log.trait = TRUE, pass.ultrametric = TRUE)
phy <- sortedData$phy
male.length <- sortedData$trait
phy.clade <- extract.clade(phy, 182)
male.length.clade <- as.matrix(male.length[match(phy.clade$tip.label, rownames(male.length)),])
transformPhylo.ML(male.length.clade , phy=phy.clade, model="bm")
transformPhylo.ML(male.length.clade , phy=phy.clade, model="delta", upperBound=2)
transformPhylo.ML(male.length.clade , phy=phy.clade, model="delta", upperBound=5)
phy.clade$node.label[which(phy.clade$node.label == "3")] <- 2
transformPhylo.ML(male.length.clade, phy=phy.clade, model="clade", nodeIDs=c(49, 54))
anolisSVL_MEDUSA <- transformPhylo.ML(male.length.clade, phy=phy.clade, model="tm1",
minCladeSize=10, nSplits=2)
data(anolis.tree)
data(anolis.data)
data.matrix(anolis.data)[,c(5,6)]
sortTraitData(anolis.tree, data.matrix(anolis.data)[,c(5,6)])
sortTraitData(anolis.tree, data.matrix(anolis.data)[,c(5,6)], "anolisSVL")
sortTraitData(anolis.tree, data.matrix(anolis.data), "anolisSVL")
sortTraitData(anolis.tree, anolis.data, "anolisSVL")
anolis.data
sortTraitData(anolis.tree, anolis.data, "Female_SVL")
sortTraitData(anolis.tree, anolis.data, c("Female_SVL", "Male_SVL"))
c("Female_SVL", "Male_SVL")
y[,data.name]
y=anolis.data
phy=anlolis.tree
phy=anolis.tree
phy
y[,data.name]
y
y[,data.name]
data.name
data.name=c("Female_SVL", "Male_SVL")
y[,data.name]
trait.data <- matrix(y[,data.name], dimnames=list(rownames(y)))
y[,data.name]
matrix(y[,data.name], dimnames=list(rownames(y)), nrow=nrow(y))
as.matrix(y[,data.name], dimnames=list(rownames(y)), nrow=nrow(y))
trait.data <- as.matrix(y[,data.name], dimnames=list(rownames(y)), nrow=nrow(y))
phy.names <- phy$tip.label#
    trait.names <- rownames(trait.data)
is.na(trait.data)
which(is.na(trait.data))
missing <- which(is.na(trait.data))
trait.data[-missing]
matrix(trait.data[-missing], dimnames = list(trait.names[-missing]))
missing <- apply(trait.data, 2, function(x) which(is.na(x)))
missing
unlist(    missing)
unique(unlist(missing))
missing <- unique(unlist(missing))
dat.trait <- matrix(trait.data[-missing], dimnames = list(trait.names[-missing]))
dat.trait <- as.matrix(trait.data[-missing], dimnames = list(trait.names[-missing]))
dat.trait
trait.names[-missing]
dat.trait <- matrix(trait.data[-missing], ncol=2, dimnames = list(trait.names[-missing]))
trait.data[-missing]
dat.trait <- matrix(trait.data[-missing,], ncol=2, dimnames = list(trait.names[-missing]))
dat.trait
rm.tip <- match(phy.names, rownames(dat.trait))
#' @title Sort data and remove missing entries for tree and trait data#
#' @description Plots a phylogeny with lines representing the value of a continuous trait#
#' @param y A matrix of trait values with taxon names as rownames. Missing values should be NA#
#' @param phy An object of class \code{phylo} or \code{multiPhylo}  (see \pkg{ape})#
#' @param data.name If null the first column of y is assummed as the trait, otherwise if y is a matrix with more than one column either the name of the column or the number of the column must be supplied by data.name#
#' @param log.trait Logical. If \code{TRUE}, data are log-transformed#
#' @param pass.ultrametric Although trees that are believed to be ultrametric to pass the function \code{is.ultrametric} in \pkg{ape}#
#' @return phy Tree with missing data pruned#
#' @return trait Rearranged data with missing species removed#
#' @author Mark Puttick#
#' @examples #
#' data(anolis.tree)#
#' data(anolis.data)#
#' attach(anolis.data)#
#' male.length <- matrix(Male_SVL, dimnames=list(rownames(anolis.data)))#
#' any(is.na(male.length[,1]))#
#' data.sorted <- sortTraitData(anolis.tree, male.length)#
#' phy <- data.sorted[[1]]#
#' male.length <- data.sorted[[2]]#
#' @export#
#
sortTraitData <- function (phy, y, data.name=NULL, log.trait = TRUE, pass.ultrametric=FALSE) #
{#
	if(is.matrix(y) || is.data.frame(y)) {#
		if(dim(y)[2] > 1) {#
			if(dim(y)[2] > 1 && is.null(data.name)) stop("not sure which column to take - please provide a data.name")#
			trait.data <- as.matrix(y[,data.name], dimnames=list(rownames(y)), nrow=nrow(y))#
			} else {#
			trait.data <- y	#
			}#
		} else {#
			trait.data <- y#
		}#
#
    if (class(phy) == "multiPhylo") {#
        tree <- phy#
        phy <- phy[[1]]#
        multi.phy <- TRUE#
    } else {#
        multi.phy <- FALSE#
    }#
    phy.names <- phy$tip.label#
    trait.names <- rownames(trait.data)#
    missing <- apply(trait.data, 2, function(x) which(is.na(x)))#
    missing <- unique(unlist(missing))#
    dat.trait <- matrix(trait.data[-missing,], ncol=2, dimnames = list(trait.names[-missing]))#
    rm.tip <- match(phy.names, rownames(dat.trait))#
    if (multi.phy) {#
        red.phy <- lapply(tree, function(x) drop.tip(x, phy.names[which(is.na(rm.tip))]))#
        class(red.phy) <- "multiPhylo"#
        trait <- dat.trait[match(red.phy[[1]]$tip.label, rownames(dat.trait)), #
            ]#
    }#
    else {#
        red.phy <- drop.tip(phy, phy.names[which(is.na(rm.tip))])#
        trait <- dat.trait[match(red.phy$tip.label, rownames(dat.trait)), ]#
    }#
    if(pass.ultrametric == TRUE)  {#
		outer <- red.phy$edge[,2]#
		node.times <- nodeTimes(red.phy)#
		externs <- which(outer <= Ntip(red.phy))#
		red.phy$edge.length[externs] <- red.phy$edge.length[externs] + (node.times[externs,2] - 1e-7)#
	}#
#
    if (log.trait) trait <- log(trait)#
    out <- list()#
    out$phy <- red.phy#
    out$trait <- as.matrix(trait)#
    return(out)#
}
sortTraitData(anolis.tree, anolis.data, c("Female_SVL", "Male_SVL"))
sortTraitData(anolis.tree, anolis.data, c("Female_SVL", "Male_SVL"), pass.ultrametric=TRUE)
sortTraitData
library(motmot.2.0)
sortTraitData
library(motmot.2.0)
tre <- rtree(10)
y <- transformPhylo.sim(tre, 1, model="bm")
transformPhylo.ML(y, tre, model="bm")
phy=tre
n <- length(phy$tip.label)#
    k <- ncol(y)#
    phy <- reorder(phy, order = "pruningwise")#
    y <- as.matrix(y[phy$tip.label, ])#
    contrasts <- apply(y, 2, pic.motmot, phy = phy)#
    rawVariances <- c(contrasts[[1]]$contr[, 2], contrasts[[1]]$V)#
    rawContrasts <- matrix(NA, nrow = n, ncol = ncol(y))
contrasts <- apply(y, 2, motmot.2.0:::pic.motmot, phy = phy)
phy=tre
if (is.matrix(y) == FALSE) {#
        stop("Trait data must be a matrix with taxon names as row names")#
    }#
    n <- length(phy$tip.label)#
    k <- ncol(y)#
    phy <- reorder(phy, order = "pruningwise")#
    y <- as.matrix(y[phy$tip.label, ])#
    contrasts <- apply(y, 2, motmot.2.0:::pic.motmot, phy = phy)#
    rawVariances <- c(contrasts[[1]]$contr[, 2], contrasts[[1]]$V)#
    rawContrasts <- matrix(NA, nrow = n, ncol = ncol(y))
for (i in 1:k) {#
        rawContrasts[, i] <- c(contrasts[[i]]$contr[, 1], 0)#
    }
brCov <- matrix(NA, nrow = ncol(y), ncol = ncol(y))
for (i in 1:k) {#
        for (j in 1:k) {#
			if(i==j|covPIC==TRUE){#
                brCov[j, i] <- brCov[i, j] <- crossprod(rawContrasts[,#
                j]/sqrt(rawVariances), rawContrasts[, i]/sqrt(rawVariances))/(n - 1)#
			}else{#
                brCov[j,i]<-0#
			}#
        }#
    }
covPIC = TRUE
meserr = NULL
phy=tre
if (is.matrix(y) == FALSE) {#
        stop("Trait data must be a matrix with taxon names as row names")#
    }#
    n <- length(phy$tip.label)#
    k <- ncol(y)#
    phy <- reorder(phy, order = "pruningwise")#
    y <- as.matrix(y[phy$tip.label, ])#
    contrasts <- apply(y, 2, motmot.2.0:::pic.motmot, phy = phy)#
    rawVariances <- c(contrasts[[1]]$contr[, 2], contrasts[[1]]$V)#
    rawContrasts <- matrix(NA, nrow = n, ncol = ncol(y))#
    for (i in 1:k) {#
        rawContrasts[, i] <- c(contrasts[[i]]$contr[, 1], 0)#
    }#
    brCov <- matrix(NA, nrow = ncol(y), ncol = ncol(y))#
    for (i in 1:k) {#
        for (j in 1:k) {#
			if(i==j|covPIC==TRUE){#
                brCov[j, i] <- brCov[i, j] <- crossprod(rawContrasts[,#
                j]/sqrt(rawVariances), rawContrasts[, i]/sqrt(rawVariances))/(n - 1)#
			}else{#
                brCov[j,i]<-0#
			}#
        }#
    }
iW <- solve(brCov)
addCons <- 0#
    for (i in 1:n) {#
        ui <- matrix(rawContrasts[i, ])#
        addCons <- addCons + crossprod(ui, iW %*% ui)/rawVariances[i]#
    }#
    logLikelihood <- -0.5 * (n * k * log(2 * pi) + n * log(det(brCov)) +#
    k * sum(log(rawVariances)) + addCons)
logLikelihood
transformPhylo.ML(y, tre, model="bm")
brCov
#' Log-likelihood estimation for traits and phylogenies#
#'#
#' This function calculates the log-likelihood and Brownian (co)variance for a trait(s) and a phylogeny using phylogenetically independent contrasts#
#' Note that \code{as.rateMatrix} calls the CAIC function \code{vcv.array} multiple times and this can be slow for large phylogenies (though faster than using the "ape" equivalent \code{vcv.phylo}).#
#' @param y A matrix of trait data. Rownames must be included and match the taxon names in the phylogeny. Can accept single traits (calculates variance) or multiple traits (calculates variance-covariance matrix).#
#' @param phy An object of class "phylo" (see \pkg{ape}).#
#' @param covPIC Logical - allow for covariance between multivariate traits (\code{TRUE}), or assume not covariance (\code{FALSE}). Only applicable to multivariate traits#
#' @param brCov If \code{NULL} (the default), Brownian covariance is analytically estimated. If a user-supplied numerical value is suppied the likelihood is calculate given this value#
#' @details The \code{phylo} object must be rooted and fully dichotomous#
#' @return brownianVariance Brownian variance (or covariance for multiple traits) given the data and phylogeny#
#' @return logLikelihood The log-likelihood of the model and data#
#' @references Felsenstein J. 1973. Maximum-likelihood estimation of evolutionary trees from continuous characters. Am. J. Hum. Genet. 25, 471-492.#
#' @references Felsenstein J. 1985. Phylogenies and the comparative method. American Naturalist 125, 1-15.#
#' @references Freckleton RP & Jetz W. 2009. Space versus phylogeny: disentangling phylogenetic and spatial signals in comparative data. Proc. Roy. Soc. B 276, 21-30. #
#' @author Gavin Thomas, Rob Freckleton#
#' @examples #
#' data(anolis.tree)#
#' data(anolis.data)#
#' ## calculate Brownian variance log-likelihood of female SVL#
#' female.svl <- matrix(anolis.data[,"Female_SVL"], #
#' dimnames=list(rownames(anolis.data)))#
#' input.data <- sortTraitData(phy=anolis.tree, y=female.svl, log.trait=TRUE)#
#' likTraitPhylo(phy = input.data$phy, y=input.data$trait)#
#' @export#
#
likTraitPhylo<-function (y, phy, covPIC = TRUE, brCov=NULL)#
{#
    if (is.matrix(y) == FALSE) {#
        stop("Trait data must be a matrix with taxon names as row names")#
    }#
    n <- length(phy$tip.label)#
    k <- ncol(y)#
    phy <- reorder(phy, order = "pruningwise")#
    y <- as.matrix(y[phy$tip.label, ])#
    contrasts <- apply(y, 2, pic.motmot, phy = phy)#
    rawVariances <- c(contrasts[[1]]$contr[, 2], contrasts[[1]]$V)   #
    rawContrasts <- sapply(contrasts, function(k) c(k$contr[, 1], 0))#
  	t.mat <- apply(rawContrasts, 2, function(x) x / sqrt(rawVariances))#
    if(is.null(brCov)) {#
    		brCov <- crossprod(t.mat, t.mat) / (n-1)#
    } else {#
    		brCov <- as.matrix(brCov)#
    }#
    if(covPIC == FALSE) {#
    		brCov[upper.tri(brCov)] <- 0#
    		brCov[lower.tri(brCov)] <- 0#
    }#
    iW <- solve(brCov)#
    addCon.mat <- apply(rawContrasts, 1, function(con) crossprod(con, iW %*% con)) / rawVariances#
    addCons <- sum(addCon.mat)#
	logLikelihood <- -0.5 * (n * k * log(2 * pi) + n * log(det(brCov)) + k * sum(log(rawVariances)) + addCons)#
    return(list(brownianVariance = brCov, logLikelihood = logLikelihood))#
}
pic.motmot
motmot.2.0:::pic.motmot
pic.motmot <- function (x, phy) #
{#
    out <- pic(x, phy, rescaled.tree = TRUE, var.contrasts = TRUE, #
        scaled = FALSE)#
    contr <- out[[1]]#
    nb.tip <- length(phy$tip.label)#
    idx <- which(out[[2]]$edge[, 1] == (nb.tip + 1))#
    root.v <- out[[2]]$edge.length[idx]#
    V <- prod(root.v)/(sum(root.v))#
    return(list(contr = contr, root.v = root.v, V = V))#
}
#' Log-likelihood estimation for traits and phylogenies#
#'#
#' This function calculates the log-likelihood and Brownian (co)variance for a trait(s) and a phylogeny using phylogenetically independent contrasts#
#' Note that \code{as.rateMatrix} calls the CAIC function \code{vcv.array} multiple times and this can be slow for large phylogenies (though faster than using the "ape" equivalent \code{vcv.phylo}).#
#' @param y A matrix of trait data. Rownames must be included and match the taxon names in the phylogeny. Can accept single traits (calculates variance) or multiple traits (calculates variance-covariance matrix).#
#' @param phy An object of class "phylo" (see \pkg{ape}).#
#' @param covPIC Logical - allow for covariance between multivariate traits (\code{TRUE}), or assume not covariance (\code{FALSE}). Only applicable to multivariate traits#
#' @param brCov If \code{NULL} (the default), Brownian covariance is analytically estimated. If a user-supplied numerical value is suppied the likelihood is calculate given this value#
#' @details The \code{phylo} object must be rooted and fully dichotomous#
#' @return brownianVariance Brownian variance (or covariance for multiple traits) given the data and phylogeny#
#' @return logLikelihood The log-likelihood of the model and data#
#' @references Felsenstein J. 1973. Maximum-likelihood estimation of evolutionary trees from continuous characters. Am. J. Hum. Genet. 25, 471-492.#
#' @references Felsenstein J. 1985. Phylogenies and the comparative method. American Naturalist 125, 1-15.#
#' @references Freckleton RP & Jetz W. 2009. Space versus phylogeny: disentangling phylogenetic and spatial signals in comparative data. Proc. Roy. Soc. B 276, 21-30. #
#' @author Gavin Thomas, Rob Freckleton#
#' @examples #
#' data(anolis.tree)#
#' data(anolis.data)#
#' ## calculate Brownian variance log-likelihood of female SVL#
#' female.svl <- matrix(anolis.data[,"Female_SVL"], #
#' dimnames=list(rownames(anolis.data)))#
#' input.data <- sortTraitData(phy=anolis.tree, y=female.svl, log.trait=TRUE)#
#' likTraitPhylo(phy = input.data$phy, y=input.data$trait)#
#' @export#
#
likTraitPhylo<-function (y, phy, covPIC = TRUE, brCov=NULL)#
{#
    if (is.matrix(y) == FALSE) {#
        stop("Trait data must be a matrix with taxon names as row names")#
    }#
    n <- length(phy$tip.label)#
    k <- ncol(y)#
    phy <- reorder(phy, order = "pruningwise")#
    y <- as.matrix(y[phy$tip.label, ])#
    contrasts <- apply(y, 2, pic.motmot, phy = phy)#
    rawVariances <- c(contrasts[[1]]$contr[, 2], contrasts[[1]]$V)   #
    rawContrasts <- sapply(contrasts, function(k) c(k$contr[, 1], 0))#
  	t.mat <- apply(rawContrasts, 2, function(x) x / sqrt(rawVariances))#
    if(is.null(brCov)) {#
    		brCov <- crossprod(t.mat, t.mat) / (n-1)#
    } else {#
    		brCov <- as.matrix(brCov)#
    }#
    if(covPIC == FALSE) {#
    		brCov[upper.tri(brCov)] <- 0#
    		brCov[lower.tri(brCov)] <- 0#
    }#
    iW <- solve(brCov)#
    addCon.mat <- apply(rawContrasts, 1, function(con) crossprod(con, iW %*% con)) / rawVariances#
    addCons <- sum(addCon.mat)#
	logLikelihood <- -0.5 * (n * k * log(2 * pi) + n * log(det(brCov)) + k * sum(log(rawVariances)) + addCons)#
    return(list(brownianVariance = brCov, logLikelihood = logLikelihood))#
}
transformPhylo.ML(y, tre, model="bm")
logLikelihood
library(motmot.2.0)
?ML.RatePhylo
## Read in phylogeny and data from Thomas et al. (2009)#
data(anolis.tree)#
data(anolis.data)#
## Convert data to class rateData with a rateMatrix object as input#
anolis.rateMatrix <- as.rateMatrix(phy=anolis.tree, x="geo_ecomorph",#
data=anolis.data)#
anolis.rateData <- as.rateData(y="Female_SVL", x="geo_ecomorph", #
rateMatrix = anolis.rateMatrix, phy=NULL, data=anolis.data, log.y=TRUE)#
# A model with a different rate in each of the four groups. The 'fixed' command is used to determine
# The default is to allow each group to take a different mean. #
ML.RatePhylo(anolis.rateData, fixed=c(1,FALSE,FALSE, FALSE), pretty=TRUE)#
# Run the same model, but this time assuming a common mean across all four groups#
ML.RatePhylo(anolis.rateData, fixed=c(1,FALSE,FALSE, FALSE), pretty=TRUE, common.mean=TRUE)
#' @title Character displacement likelihood ratio test#
#' @description Conducts a likelihood ratio test between empirical data (phylogeny and trait data), and simumlations from the function chr.disp.sim using an approximate Bayesian computation (ABC) approach (Clarke et al. 2017)#
#' @param emp.tree An empirical phylogeny - a object of class \code{phylo} (see \pkg{ape}).#
#' @param emp.data Continuous trait data matrix#
#' @param param.out simulated data from the function \code{chr.disp.sim}#
#' @param posteriorSize The number of samples to use in the likelihood-ratio test#
#' @return List containing element of 'estimates' with the estimates of sigma and a, with the Brownian motion (a = 0) summarised in column one and the character displacement (a > 0) in column two. 'likelihood' contains the likelihood of the Brownian motion model and the character displacement model, and the likelihood ratio test estimate. If used, there is an estimate of Blomberg's K for the empirical and simulated data.#
#' @useDynLib motmot.2.0#
#' @importFrom Rcpp sourceCpp#
#' @seealso \code{\link{chr.disp.sim}}, \code{\link{chr.disp.param}}#
#' @references Clarke M, Thomas GH, Freckleton RP. 2017. Trait evolution in adaptive radiations: modelling and measuring interspecific competition on phylogenies. The American Naturalist. 189, 121-137.#
#' @author Magnus Clarke and Mark Puttick#
#' @examples#
#' ## import finch data form Clarke et al. (2017)#
#' data(finches)#
#' ## simulate small amount of data #
#' ## (example only - many more datasets are required for accuracy)#
#' param.simulation <- chr.disp.param(finch.tree, n.sim = 5, #
#' max.sigma = 8, max.a = 8, ntraits=1, #
#' allopatry=as.matrix(allopatric.data), mc.cores = 1)#
#' chr.disp.lrt(finch.tree, finch.data, param.simulation, 3)#
#' @export#
#
chr.disp.lrt <- function(emp.tree, emp.data, param.out, posteriorSize=500) {#
#
    sig <- param.out[[1]][ ,1]#
    atry <- param.out[[1]][ ,2]#
    sstat <- param.out[[1]][ ,-(1:2)]#
    input.match <- param.out$input.arguments#
    max.sigma <- input.match$max.sigma#
	max.a <- input.match$max.a#
	est.blomberg.k <- input.match$est.blomberg.k#
	n.sim <- input.match$n.sim#
	n.traits <- input.match$n.traits#
	trait.lim <- input.match$trait.lim#
	# sympatry <- param.out$sympatry#
	# allopatry <- param.out$allopatry#
    # Get summary stats for the true data, and distance to sims#
    tstat <- summary_stats(phy=emp.tree, est.blomberg.k=est.blomberg.k, y=emp.data)#
    diff <- colSums(abs(t(sstat)[-3,] - unlist(tstat[-3])) ^ 2)#
#
    # Get simulations from nth closest to closest #
    h.1_post <- order(diff)[1:posteriorSize]#
    u.sig <- sig[h.1_post]#
    u.atry <- atry[h.1_post]#
    h.1_post <- matrix(ncol=2, nrow=length(u.sig))#
    h.1_post[,1] <- u.sig#
    h.1_post[,2] <- u.atry#
#
    k.out <- kde(h.1_post, xmin=c(0, 0), xmax=c(max.sigma, max.a))#
    k.0.out <- kde(h.1_post, xmin=c(0, 0), xmax=c(max.sigma, 0))#
#
    # Use kernel smoothing to estimate likelihood maxima with and without competition.#
    k.max.index <- which(k.out$estimate == max(k.out$estimate), arr.ind = TRUE)#
    h.1.lik <- k.out$estimate[k.max.index[1], k.max.index[2]]#
    h.1.est <- c(unlist(k.out$eval.points)[k.max.index[1]], unlist(k.out$eval.points)[length(k.out$estimate[,1]) + k.max.index[2]])#
#
    k.0.max.index <- which(k.0.out$estimate == max(k.0.out$estimate), arr.ind = TRUE)#
    h.0.lik <- k.0.out$estimate[k.0.max.index[1], k.0.max.index[2]]#
    h.0.est <- c(unlist(k.0.out$eval.points)[k.0.max.index[1]], unlist(k.0.out$eval.points)[length(k.0.out$estimate[,1]) + k.0.max.index[2]])#
    likelihood.ratio.test <- -2 * log( h.0.lik / h.1.lik )#
    p.value <- pchisq(likelihood.ratio.test, 1)#
    output <- list()#
    output$estimates <- data.frame(h.0.est, h.1.est)#
    rownames(output$estimates) <- c("sigma", "a")#
    output$likelihood <- data.frame(h.0.lik, h.1.lik, likelihood.ratio.test, p.value)#
	if(est.blomberg.k) output$blomberg.k <- c("empirical.blomberg.k"=unlist(tstat[3]), "simulated.mean.blomberg.k"=mean(param.out[[1]][,4]))#
	return(output)#
}
